(()=>{"use strict";new Set;const e="undefined"!=typeof window?window:"undefined"!=typeof globalThis?globalThis:global;class t{_listeners="WeakMap"in e?new WeakMap:void 0;_observer=void 0;options;constructor(e){this.options=e}observe(e,t){return this._listeners.set(e,t),this._getObserver().observe(e,this.options),()=>{this._listeners.delete(e),this._observer.unobserve(e)}}_getObserver(){return this._observer??(this._observer=new ResizeObserver((e=>{for(const n of e)t.entries.set(n.target,n),this._listeners.get(n.target)?.(n)})))}}t.entries="WeakMap"in e?new WeakMap:void 0;let n,o,i=!1;function r(e,t){e.appendChild(t)}function s(e,t,n){const o=function(e){if(!e)return document;const t=e.getRootNode?e.getRootNode():e.ownerDocument;return t&&t.host?t:e.ownerDocument}(e);if(!o.getElementById(t)){const e=c("style");e.id=t,e.textContent=n,function(e,t){r(e.head||e,t),t.sheet}(o,e)}}function a(e,t,n){e.insertBefore(t,n||null)}function l(e){e.parentNode&&e.parentNode.removeChild(e)}function c(e){return document.createElement(e)}function d(e){return document.createTextNode(e)}function h(){return d(" ")}function u(e,t,n){null==n?e.removeAttribute(t):e.getAttribute(t)!==n&&e.setAttribute(t,n)}function p(e,t,{bubbles:n=!1,cancelable:o=!1}={}){return new CustomEvent(e,{detail:t,bubbles:n,cancelable:o})}class A{is_svg=!1;e=void 0;n=void 0;t=void 0;a=void 0;constructor(e=!1){this.is_svg=e,this.e=this.n=null}c(e){this.h(e)}m(e,t,n=null){var o;this.e||(this.is_svg?this.e=(o=t.nodeName,document.createElementNS("http://www.w3.org/2000/svg",o)):this.e=c(11===t.nodeType?"TEMPLATE":t.nodeName),this.t="TEMPLATE"!==t.tagName?t:t.content,this.c(e)),this.i(n)}h(e){this.e.innerHTML=e,this.n=Array.from("TEMPLATE"===this.e.nodeName?this.e.content.childNodes:this.e.childNodes)}i(e){for(let t=0;t<this.n.length;t+=1)a(this.t,this.n[t],e)}p(e){this.d(),this.h(e),this.i(this.a)}d(){this.n.forEach(l)}}function f(){}function m(e,t,n,o,i){e.__svelte_meta={loc:{file:t,line:n,column:o,char:i}}}function $(e){return e()}function g(){return Object.create(null)}function w(e){e.forEach($)}function y(e){return"function"==typeof e}function v(e,t){return e!=e?t==t:e!==t||e&&"object"==typeof e||"function"==typeof e}function b(e,t){return e===t||(n||(n=document.createElement("a")),n.href=t,e===n.href)}function E(e){o=e}function x(){if(!o)throw new Error("Function called outside component initialization");return o}function B(e){x().$$.on_mount.push(e)}function C(e){x().$$.on_destroy.push(e)}function k(){const e=x();return(t,n,{cancelable:o=!1}={})=>{const i=e.$$.callbacks[t];if(i){const r=p(t,n,{cancelable:o});return i.slice().forEach((t=>{t.call(e,r)})),!r.defaultPrevented}return!0}}new Map;const D=[],N=[];let L=[];const _=[],j=Promise.resolve();let I=!1;function Q(e){L.push(e)}function S(e){_.push(e)}const U=new Set;let F=0;function T(){if(0!==F)return;const e=o;do{try{for(;F<D.length;){const e=D[F];F++,E(e),O(e.$$)}}catch(e){throw D.length=0,F=0,e}for(E(null),D.length=0,F=0;N.length;)N.pop()();for(let e=0;e<L.length;e+=1){const t=L[e];U.has(t)||(U.add(t),t())}L.length=0}while(D.length);for(;_.length;)_.pop()();I=!1,U.clear(),E(e)}function O(e){if(null!==e.fragment){e.update(),w(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(Q)}}const M=new Set;let R,W;function J(e,t){e&&e.i&&(M.delete(e),e.i(t))}function P(e,t,n,o){if(e&&e.o){if(M.has(e))return;M.add(e),R.c.push((()=>{M.delete(e),o&&(n&&e.d(1),o())})),e.o(t)}else o&&o()}function Z(e,t,n){const o=e.$$.props[t];void 0!==o&&(e.$$.bound[o]=n,n(e.$$.ctx[o]))}function z(e){e&&e.c()}function Y(e,t,n){const{fragment:o,after_update:i}=e.$$;o&&o.m(t,n),Q((()=>{const t=e.$$.on_mount.map($).filter(y);e.$$.on_destroy?e.$$.on_destroy.push(...t):w(t),e.$$.on_mount=[]})),i.forEach(Q)}function V(e,t){const n=e.$$;null!==n.fragment&&(function(e){const t=[],n=[];L.forEach((o=>-1===e.indexOf(o)?t.push(o):n.push(o))),n.forEach((e=>e())),L=t}(n.after_update),w(n.on_destroy),n.fragment&&n.fragment.d(t),n.on_destroy=n.fragment=null,n.ctx=[])}function H(e,t,n,r,s,a,c=null,d=[-1]){const h=o;E(e);const u=e.$$={fragment:null,ctx:[],props:a,update:f,not_equal:s,bound:g(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(h?h.$$.context:[])),callbacks:g(),dirty:d,skip_bound:!1,root:t.target||h.$$.root};c&&c(u.root);let p=!1;if(u.ctx=n?n(e,t.props||{},((t,n,...o)=>{const i=o.length?o[0]:n;return u.ctx&&s(u.ctx[t],u.ctx[t]=i)&&(!u.skip_bound&&u.bound[t]&&u.bound[t](i),p&&function(e,t){-1===e.$$.dirty[0]&&(D.push(e),I||(I=!0,j.then(T)),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}(e,t)),n})):[],u.update(),p=!0,w(u.before_update),u.fragment=!!r&&r(u.ctx),t.target){if(t.hydrate){i=!0;const e=(A=t.target,Array.from(A.childNodes));u.fragment&&u.fragment.l(e),e.forEach(l)}else u.fragment&&u.fragment.c();t.intro&&J(e.$$.fragment),Y(e,t.target,t.anchor),i=!1,T()}var A;E(h)}function X(e,t,n,o){const i=n[e]?.type;if(t="Boolean"===i&&"boolean"!=typeof t?null!=t:t,!o||!n[e])return t;if("toAttribute"===o)switch(i){case"Object":case"Array":return null==t?null:JSON.stringify(t);case"Boolean":return t?"":null;case"Number":return null==t?null:t;default:return t}else switch(i){case"Object":case"Array":return t&&JSON.parse(t);case"Boolean":default:return t;case"Number":return null!=t?+t:t}}new Set(["allowfullscreen","allowpaymentrequest","async","autofocus","autoplay","checked","controls","default","defer","disabled","formnovalidate","hidden","inert","ismap","loop","multiple","muted","nomodule","novalidate","open","playsinline","readonly","required","reversed","selected"]),"function"==typeof HTMLElement&&(W=class extends HTMLElement{$$ctor;$$s;$$c;$$cn=!1;$$d={};$$r=!1;$$p_d={};$$l={};$$l_u=new Map;constructor(e,t,n){super(),this.$$ctor=e,this.$$s=t,n&&this.attachShadow({mode:"open"})}addEventListener(e,t,n){if(this.$$l[e]=this.$$l[e]||[],this.$$l[e].push(t),this.$$c){const n=this.$$c.$on(e,t);this.$$l_u.set(t,n)}super.addEventListener(e,t,n)}removeEventListener(e,t,n){if(super.removeEventListener(e,t,n),this.$$c){const e=this.$$l_u.get(t);e&&(e(),this.$$l_u.delete(t))}}async connectedCallback(){if(this.$$cn=!0,!this.$$c){if(await Promise.resolve(),!this.$$cn)return;function e(e){return()=>{let t;return{c:function(){t=c("slot"),"default"!==e&&u(t,"name",e)},m:function(e,n){a(e,t,n)},d:function(e){e&&l(t)}}}}const t={},n=function(e){const t={};return e.childNodes.forEach((e=>{t[e.slot||"default"]=!0})),t}(this);for(const i of this.$$s)i in n&&(t[i]=[e(i)]);for(const r of this.attributes){const s=this.$$g_p(r.name);s in this.$$d||(this.$$d[s]=X(s,r.value,this.$$p_d,"toProp"))}this.$$c=new this.$$ctor({target:this.shadowRoot||this,props:{...this.$$d,$$slots:t,$$scope:{ctx:[]}}});const o=()=>{this.$$r=!0;for(const e in this.$$p_d)if(this.$$d[e]=this.$$c.$$.ctx[this.$$c.$$.props[e]],this.$$p_d[e].reflect){const t=X(e,this.$$d[e],this.$$p_d,"toAttribute");null==t?this.removeAttribute(this.$$p_d[e].attribute||e):this.setAttribute(this.$$p_d[e].attribute||e,t)}this.$$r=!1};this.$$c.$$.after_update.push(o),o();for(const d in this.$$l)for(const h of this.$$l[d]){const p=this.$$c.$on(d,h);this.$$l_u.set(h,p)}this.$$l={}}}attributeChangedCallback(e,t,n){this.$$r||(e=this.$$g_p(e),this.$$d[e]=X(e,n,this.$$p_d,"toProp"),this.$$c?.$set({[e]:this.$$d[e]}))}disconnectedCallback(){this.$$cn=!1,Promise.resolve().then((()=>{this.$$cn||(this.$$c.$destroy(),this.$$c=void 0)}))}$$g_p(e){return Object.keys(this.$$p_d).find((t=>this.$$p_d[t].attribute===e||!this.$$p_d[t].attribute&&t.toLowerCase()===e))||e}});class q{$$=void 0;$$set=void 0;$destroy(){V(this,1),this.$destroy=f}$on(e,t){if(!y(t))return f;const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(t),()=>{const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}$set(e){var t;this.$$set&&(t=e,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const G="4.2.2";function K(e,t){document.dispatchEvent(p(e,{version:G,...t},{bubbles:!0}))}function ee(e,t){K("SvelteDOMInsert",{target:e,node:t}),r(e,t)}function te(e,t,n){K("SvelteDOMInsert",{target:e,node:t,anchor:n}),a(e,t,n)}function ne(e){K("SvelteDOMRemove",{node:e}),l(e)}function oe(e,t,n,o,i,r,s){const a=!0===o?["capture"]:o?Array.from(Object.keys(o)):[];i&&a.push("preventDefault"),r&&a.push("stopPropagation"),s&&a.push("stopImmediatePropagation"),K("SvelteDOMAddEventListener",{node:e,event:t,handler:n,modifiers:a});const l=function(e,t,n,o){return e.addEventListener(t,n,o),()=>e.removeEventListener(t,n,o)}(e,t,n,o);return()=>{K("SvelteDOMRemoveEventListener",{node:e,event:t,handler:n,modifiers:a}),l()}}function ie(e,t,n){u(e,t,n),null==n?K("SvelteDOMRemoveAttribute",{node:e,attribute:t}):K("SvelteDOMSetAttribute",{node:e,attribute:t,value:n})}function re(e,t,n){for(const o of Object.keys(t))~n.indexOf(o)||console.warn(`<${e}> received an unexpected slot "${o}".`)}class se extends q{$$prop_def;$$events_def;$$slot_def;constructor(e){if(!e||!e.target&&!e.$$inline)throw new Error("'target' is a required option");super()}$destroy(){super.$destroy(),this.$destroy=()=>{console.warn("Component was already destroyed")}}$capture_state(){}$inject_state(){}}"undefined"!=typeof window&&(window.__svelte||(window.__svelte={v:new Set})).v.add("4");const ae="src/Swap.svelte";function le(e){let t,n,o,i,r;const s={c:function(){t=c("main"),n=c("div"),o=new A(!1),i=h(),r=c("div"),r.innerHTML="",o.a=i,m(r,ae,71,4,2242),m(n,ae,69,4,2209),m(t,ae,68,0,2198)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(s,a){te(s,t,a),ee(t,n),o.m(e[0],n),ee(n,i),ee(n,r)},p:function(e,[t]){1&t&&o.p(e[0])},i:f,o:f,d:function(e){e&&ne(t)}};return K("SvelteRegisterBlock",{block:s,id:le.name,type:"component",source:"",ctx:e}),s}function ce(e,t,n){let{$$slots:o={},$$scope:i}=t;re("Swap",o,[]);let{samp:r="\n    \\infer{\\land}{E}{\n            A\n            &\n            \\infer{\\lor}{D}{B & C}\n        }\n    "}=t;const s={splitr:"&",splitrRep:"\\qquad ",labelMark:"=",singleVarRep:"\\lower5pt",entail:"*",entailRep:"\\vdots"};let a="CONTENTS NOT LOADED";B((()=>{let e=[];function t(e,t){for(let n=0;n<t.length;n++)e.push(t.charAt(n));return e}for(let n=0;n<r.length;n++){let o=r.charAt(n);if(o==s.splitr)e=t(e,s.splitrRep);else if(o==s.entail){let o=[];for(let e=n;e<r.length;e++)if("{"==r.charAt(e)&&(o[0]=e),"}"==r.charAt(e)){o[1]=e;break}e=t(e,r.substring(o[0],o[1]-1)),e=t(e,s.entailRep+"}"),n=n+s.entailRep.length+o[1]-o[0]}else if(o==s.labelMark){let o=[];for(let e=n;e<r.length;e++)"["!=r.charAt(e)&&"]"!=r.charAt(e)||o.push(e);const i="{"+r.substring(o[0]+1,o[1]-2)+"}";e=t(e,i),n=n+i.length+2}else e.push(r.charAt(n))}n(0,a=e.join(""))}));const l=["samp"];return Object.keys(t).forEach((e=>{~l.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||console.warn(`<Swap> was created with unknown prop '${e}'`)})),e.$$set=e=>{"samp"in e&&n(1,r=e.samp)},e.$capture_state=()=>({createEventDispatcher:k,onMount:B,samp:r,map:s,output:a}),e.$inject_state=e=>{"samp"in e&&n(1,r=e.samp),"output"in e&&n(0,a=e.output)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[a,r]}const de=class extends se{constructor(e){super(e),H(this,e,ce,le,v,{samp:1}),K("SvelteRegisterComponent",{component:this,tagName:"Swap",options:e,id:le.name})}get samp(){throw new Error("<Swap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set samp(e){throw new Error("<Swap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},{console:he}=e;function ue(e){const t={c:f,l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:f,p:f,i:f,o:f,d:f};return K("SvelteRegisterBlock",{block:t,id:ue.name,type:"component",source:"",ctx:e}),t}const pe="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js";function Ae(e,t,n){let{$$slots:o={},$$scope:i}=t;re("MathJax",o,[]),B((()=>{let e=document.createElement("script");e.src=pe,e.onload=()=>{console.log("MathJax Loaded"),MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}},console.log("Here"),document.head.append(e)})),C((()=>{let e=document.head.getElementsByTagName("script");for(const t of e)t.getAttribute("src")==pe&&t.remove()}));const r=[];return Object.keys(t).forEach((e=>{~r.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||he.warn(`<MathJax> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({mjsource:pe,createEventDispatcher:k,onDestroy:C,onMount:B}),[]}const fe=class extends se{constructor(e){super(e),H(this,e,Ae,ue,v,{}),K("SvelteRegisterComponent",{component:this,tagName:"MathJax_1",options:e,id:ue.name})}},{console:me}=e;function $e(e){s(e,"svelte-18tku4p","div.svelte-18tku4p{background-color:#ffffff;color:rgb(54, 54, 54)}.document.svelte-18tku4p{border-width:5px;border-color:black;text-align:center;position:relative;left:15vw;width:52vw;overflow:scroll}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9jdW1lbnQuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNCSSxtQkFDSSx3QkFBeUIsQ0FDekIscUJBQ0osQ0FTQSx5QkFDSSxnQkFBZ0IsQ0FDaEIsa0JBQWtCLENBQ2xCLGlCQUFrQixDQUNsQixpQkFBaUIsQ0FDakIsU0FBUyxDQUNULFVBQVcsQ0FDWCxlQUNKIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkRvY3VtZW50LnN2ZWx0ZSJdfQ== */")}function ge(e){let t,n,o,i,r,s,a;n=new fe({$$inline:!0}),s=new de({props:{samp:e[0]},$$inline:!0});const l={c:function(){t=c("div"),z(n.$$.fragment),o=d("\n    \\("),i=d("\\newcommand{\\infer}[3]{\\cfrac{#3}{#2}\\small{#1}}"),r=d("\\)\n        "),z(s.$$.fragment),ie(t,"class","document svelte-18tku4p"),m(t,"src/Document.svelte",15,0,963)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,l){te(e,t,l),Y(n,t,null),ee(t,o),ee(t,i),ee(t,r),Y(s,t,null),a=!0},p:function(e,[t]){const n={};1&t&&(n.samp=e[0]),s.$set(n)},i:function(e){a||(J(n.$$.fragment,e),J(s.$$.fragment,e),a=!0)},o:function(e){P(n.$$.fragment,e),P(s.$$.fragment,e),a=!1},d:function(e){e&&ne(t),V(n),V(s)}};return K("SvelteRegisterBlock",{block:l,id:ge.name,type:"component",source:"",ctx:e}),l}function we(e,t,n){let{$$slots:o={},$$scope:i}=t;re("Document",o,[]);var r=this&&this.__awaiter||function(e,t,n,o){return new(n||(n=Promise))((function(i,r){function s(e){try{l(o.next(e))}catch(e){r(e)}}function a(e){try{l(o.throw(e))}catch(e){r(e)}}function l(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(s,a)}l((o=o.apply(e,t||[])).next())}))};let{ref:s}=t,{page:a}=t;console.log(a);const l=()=>r(void 0,void 0,void 0,(function*(){return a}));e.$$.on_mount.push((function(){void 0!==s||"ref"in t||e.$$.bound[e.$$.props.ref]||me.warn("<Document> was created without expected prop 'ref'"),void 0!==a||"page"in t||e.$$.bound[e.$$.props.page]||me.warn("<Document> was created without expected prop 'page'")}));const c=["ref","page"];return Object.keys(t).forEach((e=>{~c.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||me.warn(`<Document> was created with unknown prop '${e}'`)})),e.$$set=e=>{"ref"in e&&n(1,s=e.ref),"page"in e&&n(0,a=e.page)},e.$capture_state=()=>({__awaiter:r,Swap:de,MathJax:fe,ref:s,page:a,load:l}),e.$inject_state=e=>{"__awaiter"in e&&(r=e.__awaiter),"ref"in e&&n(1,s=e.ref),"page"in e&&n(0,a=e.page)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[a,s,l]}const ye=class extends se{constructor(e){super(e),H(this,e,we,ge,v,{ref:1,page:0,load:2},$e),K("SvelteRegisterComponent",{component:this,tagName:"Document",options:e,id:ge.name})}get ref(){throw new Error("<Document>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set ref(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get page(){throw new Error("<Document>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set page(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}get load(){return this.$$.ctx[2]}set load(e){throw new Error("<Document>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},{console:ve}=e,be="src/Sidebar.svelte";function Ee(e){s(e,"svelte-yazjj0",".sidebar.svelte-yazjj0{position:fixed;width:15vw;left:0;border:3px solid;border-color:#36454F;background:white;border-radius:35px;height:100vh;color:rgb(13, 13, 13);transition:all ease .3s;text-align:center;overflow:hidden}.links_to_pages.svelte-yazjj0{color:black;text-align:left;margin-right:30px;text-decoration:none;&:hover{\n      text-decoration: none;\n    }}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2lkZWJhci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaURFLHVCQUNFLGNBQWUsQ0FDZixVQUFXLENBQ1gsTUFBTyxDQUNQLGdCQUFpQixDQUNqQixvQkFBcUIsQ0FDckIsZ0JBQWlCLENBQ2pCLGtCQUFtQixDQUNuQixZQUFhLENBRWIscUJBQXNCLENBQ3RCLHVCQUF3QixDQUN4QixpQkFBa0IsQ0FDbEIsZUFDRixDQUVBLDhCQUNFLFdBQVksQ0FDWixlQUFnQixDQUNoQixpQkFBa0IsQ0FDbEIsb0JBQXFCLENBQ3JCO01BQ0UscUJBQXFCO0tBRXpCIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlNpZGViYXIuc3ZlbHRlIl19 */")}function xe(e){let t,n,o,i,r,s,a,l,d,u,p,A,$,g,y,v,b,E,x,B,C,k,D,N,L,_,j,I;const Q={c:function(){t=c("div"),n=c("div"),o=c("h1"),i=c("a"),i.textContent="Logic Manual",r=h(),s=c("div"),a=c("ul"),l=c("button"),l.textContent="Introduction to LEAN",d=h(),u=c("ul"),p=c("button"),p.textContent="Propositional Logic",A=h(),$=c("ul"),g=c("button"),g.textContent="Conjunction",y=h(),v=c("ul"),b=c("button"),b.textContent="Conditional",E=h(),x=c("ul"),B=c("button"),B.textContent="Disjunction",C=h(),k=c("ul"),D=c("button"),D.textContent="Negation",N=h(),L=c("ul"),_=c("button"),_.textContent="Putting it all together",ie(i,"href",""),m(i,be,19,6,364),m(o,be,18,4,353),m(l,be,23,10,462),m(a,be,22,8,447),m(p,be,26,10,576),m(u,be,25,8,561),m(g,be,29,10,690),m($,be,28,8,675),m(b,be,32,10,794),m(v,be,31,8,779),m(B,be,35,10,899),m(x,be,34,8,884),m(D,be,38,10,1004),m(k,be,37,8,989),m(_,be,41,10,1103),m(L,be,40,8,1088),ie(s,"class","links_to_pages svelte-yazjj0"),m(s,be,21,6,408),m(n,be,17,3,343),ie(t,"class","sidebar svelte-yazjj0"),m(t,be,14,0,295)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(c,h){te(c,t,h),ee(t,n),ee(n,o),ee(o,i),ee(n,r),ee(n,s),ee(s,a),ee(a,l),ee(s,d),ee(s,u),ee(u,p),ee(s,A),ee(s,$),ee($,g),ee(s,y),ee(s,v),ee(v,b),ee(s,E),ee(s,x),ee(x,B),ee(s,C),ee(s,k),ee(k,D),ee(s,N),ee(s,L),ee(L,_),j||(I=[oe(l,"click",e[1],!1,!1,!1,!1),oe(p,"click",e[2],!1,!1,!1,!1),oe(g,"click",e[3],!1,!1,!1,!1),oe(b,"click",e[4],!1,!1,!1,!1),oe(B,"click",e[5],!1,!1,!1,!1),oe(D,"click",e[6],!1,!1,!1,!1),oe(_,"click",e[7],!1,!1,!1,!1)],j=!0)},p:f,i:f,o:f,d:function(e){e&&ne(t),j=!1,w(I)}};return K("SvelteRegisterBlock",{block:Q,id:xe.name,type:"component",source:"",ctx:e}),Q}function Be(e,t,n){let{$$slots:o={},$$scope:i}=t;re("Sidebar",o,[]);const r=k();function s(e){console.log("emitting event, button pressed: "+e),r("documentSelection",{document:e})}const a=[];return Object.keys(t).forEach((e=>{~a.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||ve.warn(`<Sidebar> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({createEventDispatcher:k,dispatch:r,event:s}),[s,()=>s("Introduction"),()=>s("Propositional"),()=>s("Conjunction"),()=>s("Conditional"),()=>s("Disjunction"),()=>s("Negation"),()=>s("CombinedRules")]}const Ce=class extends se{constructor(e){super(e),H(this,e,Be,xe,v,{},Ee),K("SvelteRegisterComponent",{component:this,tagName:"Sidebar",options:e,id:xe.name})}},{console:ke}=e,De="src/IFrameEditor.svelte";function Ne(e){s(e,"svelte-1gzhtlv","iframe.svelte-1gzhtlv{position:fixed;overflow:hidden;flex:0.8 0 0px;right:0;top:0;height:100vh;width:30vw}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSUZyYW1lRWRpdG9yLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFZSSxzQkFDSSxjQUFlLENBQ2YsZUFBZ0IsQ0FDaEIsY0FBZSxDQUNmLE9BQVEsQ0FDUixLQUFNLENBQ04sWUFBYSxDQUNiLFVBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiSUZyYW1lRWRpdG9yLnN2ZWx0ZSJdfQ== */")}function Le(e){let t,n;const o={c:function(){t=c("iframe"),b(t.src,n=e[0])||ie(t,"src",n),ie(t,"width","300"),ie(t,"height","100vh"),ie(t,"class","svelte-1gzhtlv"),m(t,De,8,12,180)},m:function(n,o){te(n,t,o),e[2](t)},p:function(e,o){1&o&&!b(t.src,n=e[0])&&ie(t,"src",n)},d:function(n){n&&ne(t),e[2](null)}};return K("SvelteRegisterBlock",{block:o,id:Le.name,type:"key",source:"(7:8) {#key editorUrl}",ctx:e}),o}function _e(e){let t,n=e[0],o=Le(e);const i={c:function(){o.c(),t=d("")},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,n){o.m(e,n),te(e,t,n)},p:function(e,[i]){1&i&&v(n,n=e[0])?(o.d(1),o=Le(e),o.c(),o.m(t.parentNode,t)):o.p(e,i)},i:f,o:f,d:function(e){e&&ne(t),o.d(e)}};return K("SvelteRegisterBlock",{block:i,id:_e.name,type:"component",source:"",ctx:e}),i}function je(e,t,n){let{$$slots:o={},$$scope:i}=t;re("IFrameEditor",o,[]);let r,{editorUrl:s}=t,a=!0;console.log(s),e.$$.on_mount.push((function(){void 0!==s||"editorUrl"in t||e.$$.bound[e.$$.props.editorUrl]||ke.warn("<IFrameEditor> was created without expected prop 'editorUrl'")}));const l=["editorUrl"];return Object.keys(t).forEach((e=>{~l.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||ke.warn(`<IFrameEditor> was created with unknown prop '${e}'`)})),e.$$set=e=>{"editorUrl"in e&&n(0,s=e.editorUrl)},e.$capture_state=()=>({onMount:B,editorUrl:s,frame:r,frameActive:a}),e.$inject_state=e=>{"editorUrl"in e&&n(0,s=e.editorUrl),"frame"in e&&n(1,r=e.frame),"frameActive"in e&&(a=e.frameActive)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[s,r,function(e){N[e?"unshift":"push"]((()=>{r=e,n(1,r)}))}]}const Ie=class extends se{constructor(e){super(e),H(this,e,je,_e,v,{editorUrl:0},Ne),K("SvelteRegisterComponent",{component:this,tagName:"IFrameEditor",options:e,id:_e.name})}get editorUrl(){throw new Error("<IFrameEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}set editorUrl(e){throw new Error("<IFrameEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'")}},Qe="<h3> Combination of Rules</h3>\n        <p>\n            Let's look at some example natural deduction proofs combining the rules introduced above. We will discuss one example together and then there are some more exercises in the LEAN editor.  \n        </p>\n        <p>\n            Example1:  $A\\lor (B \\land C)\\vdash (A\\lor B) \\land (A \\lor C)$\n            $$\\infer{\\land Intro}{ (A\\lor B) \\land (A \\lor C)} \n            {\\infer{\\lor Elim}{A \\lor B}{A\\lor (B \\land C) &\n            \\infer{\\lor Intro}{A\\lor B}{A}& \\infer{\\lor Intro}{A\\lor B}{\\infer{\\land Elim}{B}{B\\land C}}} & \n            \\infer{\\lor Elim}{A\\lor C}{A\\lor (B \\land C) & \\infer{\\lor Intro}{A\\lor C}{A}& \\infer{\\lor Intro}{A\\lor C}{\\infer{\\land Elim}{C}{B\\land C}}}} $$   \n        </p>\n",Se='<h3> Conditional</h3>\n<p> The inference rules for the classical material conditional in propositional logic are the following: \n    $$\\infer{\\rightarrow Intro}{A\\rightarrow B} {\\underset{B}{\\overset{[A]}{\\vdots} }}$$ \n\n    $$\\infer{\\rightarrow Elim}{B} {A\\rightarrow B&A}$$\n</p>\n<p> Their LEAN implementation functions in a parallel way. First, let\'s look at the simpler case, the elimination of the conditional, the rule of Modus Ponens. \n    The rule goes as follows, given two assumptions $(h1: A \\rightarrow B)$ $(h2: A)$ you can deduce B. In LEAN this is simply written as: \n     <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">h1</span> h2\n    </pre></div> \n    The introduction of the conditional is slightly more complex. By the introduction of the conditional, one discharges the assumption of the antecedent. In our case the assumption is A. \n    The discharged assumption is indicated by the square brackets [ ] in the rule of propositional logic. In LEAN this discharging of the assumption works via a so called tactic. The tactic is fun and may be familiar to you from $\\lambda$ calculus. But this is not important here, it simply works like an assumption:  </p>\n    <p>\n    fun h: Antecedent $\\Rightarrow$ Consequent\n    </p>\n    <p>\n    $\\Rightarrow$ can be written using your keyboard, first the equality sign and then the greater than. See the code editor for an example. \n    The h: stands for hypothesis, you designate the Antecedent as an hypothesis.  You can define more complex statements in the antecedent. But importantly, with the assumption of the antecedent, you prove the consequent. </p>\n    Here are three examples of natural deduction proofs involving the rules for the conditional. \n    There are some more examples so that the functioning of the fun tactic becomes clear.\n    Below you see the deduction in propositional logic, see the code editor for their LEAN implementation.\n   </par>\n   <par>\n    Example 1: $A \\rightarrow B, B\\rightarrow C, A \\vdash C$\n\n    $$\\infer{\\rightarrow Elim}{C}{B\\rightarrow C &\\infer{\\rightarrow Elim}{B}{A\\rightarrow B & A}}$$\n\n    Example 2: $\\vdash A \\rightarrow A \\land A$\n\n    $$\\infer{\\rightarrow Intro}{A\\rightarrow A \\land A}{\\infer=[\\land Intro]{A\\land A}{[A] & {[A]}}}$$\n\n    Example 3: $A\\rightarrow B, B\\rightarrow C \\vdash A \\rightarrow C$\n    $$\\infer{\\rightarrow Intro}{A\\rightarrow C}{\\infer{\\rightarrow Elim} {C}{B \\rightarrow C & \\infer{\\rightarrow Elim}{B} {A\\rightarrow B & [A]}}}$$ \n</p>\n<p>\n    Now you can test your understanding in the exercises in the LEAN editor and replace the "sorry" placeholders with your deductions.\n</p>',Ue='<h3>Conjunction</h3>\n        <p> The well-known rules for conjunction in propositional logic are the following:\n            $$\\infer{\\land Intro}{A\\land B}{A&B}$$ \n            $$\\infer{\\land Elim} {A} {A\\land B}$$ \n            $$\\infer{\\land Elim} {B} {A\\land B}$$ </p> \n\n    In the programming language LEAN, the rules function similarly. For example, in the LEAN syntax you write:\n<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.right h\n</pre></div>\n    This extracts from the hypothesis h: $A \\land B$ the right conjunct A.\n\n    Similarly, to get the left conjunct, you can use the following syntax in LEAN\n\n<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BB0066; font-weight: bold"></span><span style="color: #333333"></span>  <span style="color: #000000; font-weight: bold">And</span><span style="color: #333333">.</span><span style="color: #008800; font-weight: bold">left</span> h\n</pre></div>\n\n    We have to be specific in LEAN, indicating exactly which conjunct we want to extract. \n    For the introduction of a conjunction of A and B we write:\n\n<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.intro <span style="color: #BB0066; font-weight: bold">A</span> <span style="color: #BB0066; font-weight: bold">B</span>\n</pre></div>\n\n<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">And</span>.intro hA hB\n</pre></div>\n\n   The latter formulation works for hypothesis hA, hB respectively. \n</p>\n<p>\n   Next let us consider an example natural deduction proof involving both the introduction and the elimation rules for conjunction: \n       </p>\n         <p>\n        Example 1: $B \\land A \\vdash A \\land B$\n         $$\\infer{\\land Intro}\n             {A\\land B} \n               {\\infer{\\land Elim} {A} {B \\land A}\n               & \\infer{\\land Elim}{B} {B \\land A}}\n                  $$\n        </p>\n    This proof is also done in LEAN; as you can see in the code editor on the page. \n    This should give you an example to then continue the exercises in LEAN using the syntax for conjunction we just introduced. There are easier and harder exercises. You just remove the "sorry" placeholer and write your proof. You should be able to see LEAN messages regarding your proof. \n\n    <p> \n        Lastly, there is one helpful tool. When you write down natural deduction proofs on paper, you might want to use intermediary steps, similarly online. See for example the last hard exercise in the LEAN editor. It could be helpful to prove C as an intermediary goal there.\n        LEAN allows you to do this by writing \n        <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #BB0066; font-weight: bold"></span><span style="color: #333333"></span>  <span style="color: #000000; font-weight: bold">show</span><span style="color: #333333"> C </span><span style="color: #008800; font-weight: bold">from And.right (And.right h)</span>\n        </pre></div>\n        \n    </p>\n\n',Fe='<h3>Disjunction</h3>\n        <p> \n            The rules for disjunction in propositional logic are the following: \n            $$\\infer{\\lor Intro} {A\\lor B} {A}$$   $$\\infer{\\lor Intro} {A\\lor B} {B}$$ \n            $$\\infer{\\lor Elim} {C} {A \\lor B & {\\underset{C}{\\overset{[A]}{\\vdots}}} & {\\underset{C}{\\overset{[B]}{\\vdots}}}}$$\n        </p>\n        <p> The syntax of the rules in LEAN is again very similar. For the introduction of the disjunction, you can use one of the following. Note in LEAN the order of the disjuncts matters.\n            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">Or.intro_left</span> A  B \n            </pre></div>\n            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">Or.intro_right</span> B  A \n            </pre></div> \n            The syntax for the disjunction elimination rule is a bit more complicated. You need to show that C follows from both A and B independently to be able to eliminate the disjunction.\n            This is done using the same tactic we saw with the conditional "fun". So we write \n            $$\\text{Or.elim } A \\lor B \\quad (\\text{ fun } h1: A \\Rightarrow C) ( \\text{fun } h1:B \\Rightarrow C)$$\n           \n        <p>\n            Now look at an example natural deduction proof using the rules for conjunction and its implementation in LEAN. \n            Example 1: $A\\lor B \\vdash A \\lor (B \\lor C)$\n            $$\\infer{\\lor Elim}{A\\lor (B \\lor C)}{A\\lor B &\\infer{\\lor Intro}{A\\lor (B\\lor C)}{[A]} & \\infer{\\lor Intro}{A\\lor (B\\lor C)}{\\infer{\\lor Intro}{B\\lor C}{[B]}}} $$\n            And there are again some exercises for you to complete in LEAN in the editor. \n        </p>\n    \n',Te='<html>\n  <head>\n    <link rel="stylesheet" href="introduction.css">\n    \x3c!-- Link to an external CSS file --\x3e\n    <link rel="stylesheet" href="style.css">\n    \x3c!-- Load MathJax script --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"><\/script>\n    <script type="text/javascript">\n      MathJax.Hub.Config({\n      tex2jax: {\n      inlineMath: [ [\'$\',\'$\'], [\'\\\\(\',\'\\\\)\'] ]\n          }\n        });\n    <\/script>\n  </head>\n\n  <body>\n    <div class="container">\n      \x3c!-- Use semantic elements for structure --\x3e\n      <nav class="navbar">\n        \x3c!-- Use descriptive class names --\x3e\n        <div>\n          <h1 class="logo"><a href="index.html">LEAN and the Logic Manual</a></h1>\n        </div>\n      </nav>\n\n      <section class="lean_intro">\n        \x3c!-- Use section element for each section --\x3e\n        <article class="lean_intro_body">\n          \x3c!-- Use article element for main content --\x3e\n          <h1> Introduction To Using Lean </h1>\n          <p> This section gives you the fundamental background to using LEAN. We introduce the LEAN syntax so that you can write the logical connectives.  \n              This will be particularly helpful in the next sections, when we go through the introduction and elimination rules of each connective. You will be able to verify your reasoning directly, being guided by the LEAN editor. </p>\n          <p> LEAN is an automated theorem prover so if you input your deduction, it will show you errors and lead you to the correct path. \n              We will familiarise ourselves with the basic reasoning in propositional logic, but LEAN is much more powerful. It is used for example at Imperial College by Kevin Buzzard to teach mathematics to undergraduates. The tool can help verify diffuclt proofs.\n            </p>\n            <p> \n            With this resource, you can familiarise yourself with the basics of the LEAN and learn logical deductions. \n          \n            You will have already seen the LEAN editor on the right. This is where you can write LEAN. \n            But before writing in LEAN, we need to learn its syntax. \n            How can you write the connective in the programming language? See the table below for instructions:\n          </p>\n\n        <article class="syntax_para">\n            <h2> Using Connectives in Lean</h2>\n            <table class="syntax_table">\n              <colgroup>\n                <col style="border: 17%">\n                <col style="width: 30%">\n                <col style="width: 52%">\n              </colgroup>\n              <tbody>\n                <tr class="row-odd">\n                  <td>\n                    <p>Symbol </p>\n                    </td>\n                  <td>\n                    <p>LEAN </p>\n                    </td>\n                  <td>\n                    <p>English </p>\n                  </td>\n                  <td>\n                    <p>Connective</p>\n                  </td>\n                </tr>\n                <tr class="row-even">\n                  <td>\n                    <p>∨</p>\n                    </td>\n                  <td>\n                    <p>\\or</p>\n                    </td>\n                    <td>\n                      <p>or </p>\n                    </td>\n                    <td>\n                      <p>Disjunction</p>\n                    </td>\n                </tr>\n                <tr class="row-odd">\n                  <td>\n                    <p>∧</p>\n                    </td>\n                  <td>\n                    <p>\\and</p>\n                    </td>\n                  <td>\n                    <p> and </p>\n                  </td>\n                  <td>\n                    <p>Conjunction</p>\n                  </td>\n                </tr>\n                <tr class="row-even">\n                  <td>\n                    <p>→</p>\n                    </td>\n                  <td>\n                    <p>\\to, \\r, \\imp </p>\n                    </td>\n                  <td>\n                    <p>if ... then </p>\n                  </td>\n                  <td>\n                    <p>Conditional</p>\n                  </td>\n                </tr>\n                <tr class="row-odd">\n                  <td>\n                    <p>↔︎</p>\n                    </td>\n                  <td>\n                    <p>\\iff, \\lr</p>\n                    </td>\n                  <td>\n                    <p>if and only if </p>\n                  </td>\n                  <td>\n                    <p>Biconditional </p>\n                  </td>\n                </tr>\n                <tr class="row-even">\n                  <td>\n                    <p>￢</p>\n                    </td>\n                  <td>\n                    <p>\\not, \\neg</p>\n                    </td>\n                  <td>\n                    <p>not </p>\n                  </td>\n                  <td>\n                    <p>Negation </p>\n                  </td>\n                </tr>\n              </tbody>\n            </table>\n        </article>\n      </section>\n    </div>\n    You may have noticed the following line at the top of the LEAN editor window:\n        <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">variable</span>(A B C D: Prop)\n        </pre></div>\n    It specifies propositions in the language. In the Logic Manual, Halbach calls these sentence letters. Now a proposition is a sentence which has a truth value. \n    A semantic structure assigns a truth value to exactly every sentence letter of the language. Hence, we can understand the sentence letters as propositions here. The semantics of propositional logic are discussed in detail in the next section.\n    <p>\n    By definition 2.2 in the Logic Manual, we know for sentence letters A,B that binary connectives $\\land, \\lor, \\rightarrow, \\leftrightarrow$ produce new sentences $A\\land B, A\\lor B, A\\rightarrow B, A \\leftrightarrow B$.\n    Similarly, for a sentence A and negation, $\\neg A$ is also a sentence.\n    You can confirm this by hovering over the statements in the code editor. We defined A, B as propositions and hence if we check expressions such as $A\\land B$, LEAN will give that these are also propositions.\n    We look at the semantics in the next section.\n    </p>\n    <p>\n      Acknowledgements: This project depends on the resources of the Book\n      <a href="https://leanprover.github.io/logic_and_proof/index.html">Logic and Proof</a> especially pertaining to LEAN,\n      the <a href="https://users.ox.ac.uk/~logicman/">Resources</a>\n      of the Logic Manual Book by Volker Halbach are the fundation for all exercises. In particular, the Natural Deduction Pack.\n      Moreover, we use the server of the ADAM project of HHU Düsseldorf. \n    </p>\n</body>\n</html>\n',Oe='<h3> Negation</h3>\n        <p>\n            The rules for negation in propositional logic are well known to you.  \n            $$\\infer{\\neg Intro} {\\neg A} { {\\underset{B}{\\overset{[A]}{\\vdots}} &  {\\underset{\\neg B}{\\overset{[A]}{\\vdots}}}}}$$  $$\\infer{\\neg Elim } { A}  {\\underset{B}{\\overset{[\\neg A]}{\\vdots}} &  {\\underset{\\neg B}{\\overset{[\\neg A]}{\\vdots}}}}$$\n        </p>\n        <p>\n            This works differently in LEAN. Negation $\\neg A$ is here defined as $A \\rightarrow \\bot$, where $\\bot$ is a contradiction such as $ 0\\neq 0 $ for example.\n            There are two main tactics for negation in LEAN. The first one is similar to negation introduction. If you want to prove $\\neg A$ then you assume $A$ and show that it leads to a contradiction. \n            This assumption is constructed similarly to the conditional and disjunctive rules above. So under the assumption  $h1:$ $ A$, you proof a contradiction (this is called False in LEAN). Then you get the desired result $\\neg A$. It is written as follows:\n            $$ \\text{fun }h: A, \\text{ show False from } h1 \\quad h$$\n           \n            Here h1 and h, defined as $\\neg A$ and $A$ respectively, gives the False. Note that the order matters here, the negated statement must come first. \n        </p>\n        <p></p>\n            The second tactic involving negation used in LEAN is the so called Ex falso quodlibet principle, which you have seen in class as well. It states that anything can be derived from a contradiction. In LEAN this is done by a new tactic: absurd. \n            So suppose you are given some contradictory assumptions such as h1: $ A$ and h2: $\\neg A$. Then you can prove any claim $B$ simply by stating \n            <div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #fabd4e; font-weight: bold">absurd</span> h2 h1\n            </pre></div>\n            Again here the order matters. \n        </p>\n        <p>\n            Let\'s look at some example derivations both in propositional logic and LEAN. Again, you can find exercises in the editor. \n            Example 1: $A\\rightarrow B, \\neg B\\vdash \\neg A$\n            $$\\infer{\\neg Intro}{\\neg A}{\\infer{\\rightarrow Elim}{B}{A\\rightarrow B & [A]} & \\neg B}$$\n            Example 2: $A\\land B, \\neg A\\vdash C$\n            $$\\infer=[  ]{C}{\\infer{\\land Elim}{A}{A\\land B}&\\neg A}$$\n        </p>\n',Me="<h1>\n    Propositional Logic in LEAN\n    </h1>\n    <div>\n       <p>\n        In the introduction, we learned how to write compound sentences in LEAN. This section will discuss the semantics of Propositional Logic, following Chapter 5 of the Logic Manual. \n        </p> \n        <p>\n        First, a small warning: please do not consider the first 6 lines of the code editor, this is just LEAN background functioning. \n        You already will have seen that a semantic structure assigns truth values to sentences in the language. \n        We do this here for a toy model by hand and declare sentences A, C as true and B, D as false. Now following the definition of satisfaction (Def 5.2) you can evaluate the truth value of compound expressions. \n        This is typically done via truth tables, where you identify the central connective and then deduce whether the expression is true or false based on its components. \n        Now LEAN does this automatically for you. If you hover over the #eval statements, then you should be able to see 'true' or 'false'. \n        </p>\n        <p>\n        Test your own examples here! You can define your own assigments and evaluate more complex expression. This is a good place to learn using LEAN and familiarise yourself with the connectives. \n        </p>\n        In the next few sections, we will look at the natural deduction rules for propositional logic. We look at the introduction and elimination rules for each connective separately and learn their implementation in LEAN.\n        This will allow you do natural deduction proofs in LEAN and have them checked automatically. \n    \n    \n    ",Re="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Combinations%20of%20rules%0Aexample%20(h%3AA%E2%88%A8%20(B%E2%88%A7%20C))%3A(A%E2%88%A8%20B)%20%E2%88%A7%20(A%20%E2%88%A8%20C)%3A%3D%0A%20%20And.intro%20%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AA%20%3D%3E%20Or.intro_left%20B%20h1)%0A%20%20(fun%20h2%3AB%E2%88%A7C%20%3D%3E%20Or.intro_right%20A%20(And.left%20h2)))%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AA%20%3D%3E%20Or.intro_left%20C%20h1)%0A%20%20(fun%20h2%3AB%E2%88%A7C%20%3D%3E%20Or.intro_right%20A%20(And.right%20h2)))%0A%0Aexample%20(h%3A%20(A%E2%86%92%20B)%E2%86%92%20B)%3A%20%C2%ACB%20%E2%86%92%20A%3A%3D%0A%20%20sorry%20%0A%0Aexample%20%3A%20%C2%AC%20(A%E2%88%A7B)%20%E2%86%92%20%20(%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%3A%3D%0A%20%20sorry%0A%0Aexample%3A%20%20(%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%20%E2%86%92%20%20%C2%AC%20(A%E2%88%A7B)%3A%3D%0A%20%20sorry%20%0A%0Aexample%20(h1%3A%20A%20%E2%86%92%20B)(h2%3A%20A%20%E2%88%A7%20%C2%AC%20B)%3A%20C%3A%3D%0A%20%20sorry%0A%20%20%0A%0A",We="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Conditional%3A%20Example%20(See%20website)%0Aexample%20(h1%3A%20A%E2%86%92%20B)(h2%3A%20B%E2%86%92%20C)%20(h3%3A%20A)%3A%20C%3A%3D%0A%20%20h2%20(show%20B%20from%20h1%20h3)%0A%0Aexample%3A%20%20A%E2%86%92%20A%20%E2%88%A7%20A%3A%3D%0A%20%20%20fun%20h%3A%20A%20%3D%3E%20%20And.intro%20h%20h%20%0A%0Aexample%20(h1%3A%20A%E2%86%92%20B%20)(h2%3A%20B%E2%86%92%20C)%3A%20A%E2%86%92%20C%3A%3D%0A%20(fun%20h%3A%20A%3D%3E%0A%20%20show%20C%20from%20h2%20(show%20B%20from%20h1%20h))%0A%0A--%20easy%20Exercises%20%0Aexample%20(h1%3A%20A%E2%86%92%20B)(h2%3A%20A)%3A%20B%3A%3D%0Asorry%20%0A%0Aexample%3A%20A%E2%86%92%20B%3A%3D%0Asorry%20%0A%0Aexample%3A%20A%20%E2%86%92%20B%20%E2%86%92%20A%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20(A%E2%86%92B)%E2%86%92A%20)%3A%20B%E2%86%92%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%20%E2%86%92%20B%3A%3D%0Asorry%20%0A%0A%0A",Je="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A--%20Conjunction%3A%20Example%20(See%20Website)%0Aexample%20(h1%20%3A%20A%20%E2%88%A7%20B)%3A%20B%20%E2%88%A7%20A%20%3A%3D%0A%20%20And.intro%20(And.right%20h1)%20(And.left%20h1)%0A%0A--%20easy%20Exercises%20%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20B%3A%3D%0Asorry%20%20%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%20%E2%88%A7%20B%20%E2%88%A7%20A%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20A%E2%88%A7B)(h2%3A%20C)%3A%20A%20%E2%88%A7%20B%20%E2%88%A7%20C%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20A%20%E2%88%A7%20(B%20%E2%88%A7%20C))%3A%20(C%20%E2%88%A7%20A)%20%E2%88%A7%20B%3A%3D%0Asorry%20%20%0A%0A",Pe="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Disjunction%3A%20Example%20(See%20Website)%0Aexample%20(h%3AA%E2%88%A8%20B)%3AA%E2%88%A8%20(B%E2%88%A8%20C)%3A%3D%0A%20%20Or.elim%20h%0A%20%20(fun%20h1%3A%20A%20%3D%3E%20%0A%20%20%20%20%20%20show%20A%E2%88%A8%20(B%E2%88%A8C)%20from%20Or.intro_left%20(B%E2%88%A8C)%20h1)%0A%20%20(fun%20h2%3AB%20%3D%3E%20%0A%20%20%20%20show%20A%E2%88%A8%20(B%E2%88%A8C)%20from%20Or.intro_right%20A%20(Or.intro_left%20C%20h2))%0A%0A%0A--%20easy%20Exercises%0Aexample%20(h%3AA)%3AA%E2%88%A8%20B%3A%3D%0Asorry%0A%0Aexample%20(h%3AA%E2%88%A8B)%3A%20B%E2%88%A8%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20(A%20%E2%86%92%20B)%E2%88%A8%20B)%3A%20A%E2%86%92%20B%20%3A%3D%0Asorry%0A%0A--%20harder%20Exercises%0Aexample%20(h%3A%20(A%E2%88%A8%20B)%20%E2%88%A7%20(A%20%E2%88%A8%20C))%3A%20A%20%E2%88%A8%20(B%E2%88%A8%20C)%3A%3D%0Asorry%20%0A%0A%0A",Ze="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A%23check%20A%20%E2%88%A8%20B%0A%0A%23check%20A%E2%88%A7%20B%0A%0A%23check%20A%20%E2%86%92%20B%0A%0A%23check%20A%20%E2%86%94%20B%0A%0A%23check%20%C2%AC%20A\n",ze="https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Negation%3A%20Example%20(See%20Website)%0Aexample%20(h1%3AA%E2%86%92%20B)%20(h2%3A%20%C2%ACB)%3A%20%C2%AC%20A%3A%3D%0A%20%20fun%20h%3A%20A%3D%3E%0A%20%20show%20False%20from%20h2%20(h1%20h)%0A%0Aexample%20(h1%3A%20A%20%E2%88%A7%20B)(h2%3A%20%C2%AC%20A)%3A%20B%20%3A%3D%0A%20%20absurd%20(And.left%20h1)%20h2%0A%0A--easy%20Exercises%0Aexample%20(h1%3AA)%3A%20%C2%AC%20%C2%AC%20A%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20A)%20(h2%3A%20%C2%AC%20A)%3A%20B%3A%3D%0Asorry%0A%0Aexample%20(h1%3A%20A%E2%88%A7%20%C2%AC%20A)%3A%20B%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20A%20%E2%86%92%20%C2%ACA)%3A%20%C2%AC%20A%3A%3D%0Asorry%20%0A%0A--harder%20Exercises%0Aexample%20(h1%3A%20A%E2%86%92%20B)%20(h2%3A%20A%20%E2%88%A7%20%C2%AC%20B)%3A%20C%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%3A%20%C2%AC%20(A%20%E2%88%A7%20B)%3A%3D%0Asorry%20%0A%0A%0A",Ye="https://lean.math.hhu.de/#code=inductive%20Bool%20%3A%20Type%20where%0A%20%20%7C%20false%0A%20%20%7C%20true%0A%0Adef%20interpret%20(p%3AProp)%20%5BDecidable%20p%5D%3A%20String%3A%3D%0Aif%20p%20then%20%22true%22%20else%20%22false%22%0A%0Adef%20A%20%3A%3D%20true%0Adef%20B%20%3A%3D%20false%0Adef%20C%20%3A%3D%20true%0Adef%20D%3A%3D%20false%20%0A%0A%23eval%20interpret%20(A%E2%88%A7B)%0A%23eval%20interpret%20(A%E2%88%A7%20(%C2%AC%20B%E2%88%A8%20%C2%ACC%20))%0A%23eval%20interpret%20(%C2%AC%20B%20%E2%86%92%20(A%20%E2%88%A8%20%C2%AC%20D))%0A%23eval%20interpret%20(D%20%E2%86%94%20(C%20%E2%88%A7%20A))",{console:Ve}=e,He="src/App.svelte";function Xe(e){s(e,"svelte-1kdsmws","@media(min-width: 640px){main.svelte-1kdsmws{max-width:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUErRUkseUJBQ0ksb0JBQ0MsY0FDRCxDQUNKIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFwcC5zdmVsdGUiXX0= */")}function qe(e){let t,n,o;function i(t){e[3](t)}let r={ref:"document"};void 0!==e[0]&&(r.page=e[0]),t=new ye({props:r,$$inline:!0}),N.push((()=>Z(t,"page",i)));const s={c:function(){z(t.$$.fragment)},m:function(e,n){Y(t,e,n),o=!0},p:function(e,o){const i={};!n&&1&o&&(n=!0,i.page=e[0],S((()=>n=!1))),t.$set(i)},i:function(e){o||(J(t.$$.fragment,e),o=!0)},o:function(e){P(t.$$.fragment,e),o=!1},d:function(e){V(t,e)}};return K("SvelteRegisterBlock",{block:s,id:qe.name,type:"key",source:"(40:4) {#key selectedDocument}",ctx:e}),s}function Ge(e){let t,n,o,i,r,s,a,l,d=e[0];n=new Ce({$$inline:!0}),n.$on("documentSelection",e[2]);let u=qe(e);function p(t){e[4](t)}let A={};void 0!==e[1]&&(A.editorUrl=e[1]),s=new Ie({props:A,$$inline:!0}),N.push((()=>Z(s,"editorUrl",p)));const $={c:function(){t=c("body"),z(n.$$.fragment),o=h(),i=c("main"),u.c(),r=h(),z(s.$$.fragment),ie(i,"class","svelte-1kdsmws"),m(i,He,45,2,2032),m(t,He,43,0,1961)},l:function(e){throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option")},m:function(e,a){te(e,t,a),Y(n,t,null),ee(t,o),ee(t,i),u.m(i,null),ee(i,r),Y(s,i,null),l=!0},p:function(e,[t]){1&t&&v(d,d=e[0])?(R={r:0,c:[],p:R},P(u,1,1,f),R.r||w(R.c),R=R.p,u=qe(e),u.c(),J(u,1),u.m(i,r)):u.p(e,t);const n={};!a&&2&t&&(a=!0,n.editorUrl=e[1],S((()=>a=!1))),s.$set(n)},i:function(e){l||(J(n.$$.fragment,e),J(u),J(s.$$.fragment,e),l=!0)},o:function(e){P(n.$$.fragment,e),P(u),P(s.$$.fragment,e),l=!1},d:function(e){e&&ne(t),V(n),u.d(e),V(s)}};return K("SvelteRegisterBlock",{block:$,id:Ge.name,type:"component",source:"",ctx:e}),$}function Ke(e,t,n){let{$$slots:o={},$$scope:i}=t;re("App",o,[]);let r=new Map;r.set("CombinedRules",[Qe,Re]),r.set("Conditional",[Se,We]),r.set("Conjunction",[Ue,Je]),r.set("Disjunction",[Fe,Pe]),r.set("Introduction",[Te,Ze]),r.set("Propositional",[Me,Ye]),r.set("Negation",[Oe,ze]);let s=Te,a=Ze;function l(e){const t=r.get(e.detail.document);n(0,s=t[0]),n(1,a=t[1]),console.log("caught event in App.svelte: "+s)}const c=[];return Object.keys(t).forEach((e=>{~c.indexOf(e)||"$$"===e.slice(0,2)||"slot"===e||Ve.warn(`<App> was created with unknown prop '${e}'`)})),e.$capture_state=()=>({Document:ye,Sidebar:Ce,IFrameEditor:Ie,CombinedRules:Qe,Conditional:Se,Conjunction:Ue,Disjunction:Fe,Introduction:Te,Negation:Oe,Propositional:Me,CombinedRulesT:Re,ConditionalT:We,ConjunctionT:Je,DisjunctionT:Pe,IntroductionT:Ze,NegationT:ze,PropositionalT:Ye,map:r,selectedDocument:s,editorText:a,handlePageChange:l}),e.$inject_state=e=>{"map"in e&&(r=e.map),"selectedDocument"in e&&n(0,s=e.selectedDocument),"editorText"in e&&n(1,a=e.editorText)},t&&"$$inject"in t&&e.$inject_state(t.$$inject),[s,a,l,function(e){s=e,n(0,s)},function(e){a=e,n(1,a)}]}new class extends se{constructor(e){super(e),H(this,e,Ke,Ge,v,{},Xe),K("SvelteRegisterComponent",{component:this,tagName:"App",options:e,id:Ge.name})}}({target:document.body,props:{name:"world"}})})();
//# sourceMappingURL=bundle.js.map