{"version":3,"file":"build/bundle.js","mappings":"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","sources":["webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/loop.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/globals.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/dom.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/utils.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/lifecycle.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/style_manager.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/scheduler.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/transitions.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/Component.js","webpack://Lean Four King's College London/./node_modules/svelte/src/shared/boolean_attributes.js","webpack://Lean Four King's College London/./node_modules/svelte/src/shared/version.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/dev.js","webpack://Lean Four King's College London/./node_modules/svelte/src/runtime/internal/disclose-version/index.js","webpack://Lean Four King's College London/./src/Swap.svelte","webpack://Lean Four King's College London/./src/MathJax.svelte","webpack://Lean Four King's College London/./src/Document.svelte","webpack://Lean Four King's College London/./src/Sidebar.svelte","webpack://Lean Four King's College London/./src/IFrameEditor.svelte","webpack://Lean Four King's College London/./src/static/documents/CombinedRules.x.html","webpack://Lean Four King's College London/./src/static/documents/Conditional.x.html","webpack://Lean Four King's College London/./src/static/documents/Conjunction.x.html","webpack://Lean Four King's College London/./src/static/documents/Disjunction.x.html","webpack://Lean Four King's College London/./src/static/documents/Introduction.x.html","webpack://Lean Four King's College London/./src/static/documents/Negation.x.html","webpack://Lean Four King's College London/./src/static/documents/Propositional.x.html","webpack://Lean Four King's College London/./src/static/exercises/CombinedRules.txt","webpack://Lean Four King's College London/./src/static/exercises/Conditional.txt","webpack://Lean Four King's College London/./src/static/exercises/Conjunction.txt","webpack://Lean Four King's College London/./src/static/exercises/Disjunction.txt","webpack://Lean Four King's College London/./src/static/exercises/Introduction.txt","webpack://Lean Four King's College London/./src/static/exercises/Negation.txt","webpack://Lean Four King's College London/./src/static/exercises/Propositional.txt","webpack://Lean Four King's College London/./src/App.svelte","webpack://Lean Four King's College London/./src/main.ts"],"sourcesContent":["import { raf } from './environment.js';\n\nconst tasks = new Set();\n\n/**\n * @param {number} now\n * @returns {void}\n */\nfunction run_tasks(now) {\n\ttasks.forEach((task) => {\n\t\tif (!task.c(now)) {\n\t\t\ttasks.delete(task);\n\t\t\ttask.f();\n\t\t}\n\t});\n\tif (tasks.size !== 0) raf(run_tasks);\n}\n\n/**\n * For testing purposes only!\n * @returns {void}\n */\nexport function clear_loops() {\n\ttasks.clear();\n}\n\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n * @param {import('./private.js').TaskCallback} callback\n * @returns {import('./private.js').Task}\n */\nexport function loop(callback) {\n\t/** @type {import('./private.js').TaskEntry} */\n\tlet task;\n\tif (tasks.size === 0) raf(run_tasks);\n\treturn {\n\t\tpromise: new Promise((fulfill) => {\n\t\t\ttasks.add((task = { c: callback, f: fulfill }));\n\t\t}),\n\t\tabort() {\n\t\t\ttasks.delete(task);\n\t\t}\n\t};\n}\n","/** @type {typeof globalThis} */\nexport const globals =\n\ttypeof window !== 'undefined'\n\t\t? window\n\t\t: typeof globalThis !== 'undefined'\n\t\t? globalThis\n\t\t: // @ts-ignore Node typings have this\n\t\t  global;\n","import { globals } from './globals.js';\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nexport class ResizeObserverSingleton {\n\t/**\n\t * @private\n\t * @readonly\n\t * @type {WeakMap<Element, import('./private.js').Listener>}\n\t */\n\t_listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n\t/**\n\t * @private\n\t * @type {ResizeObserver}\n\t */\n\t_observer = undefined;\n\n\t/** @type {ResizeObserverOptions} */\n\toptions;\n\n\t/** @param {ResizeObserverOptions} options */\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Element} element\n\t * @param {import('./private.js').Listener} listener\n\t * @returns {() => void}\n\t */\n\tobserve(element, listener) {\n\t\tthis._listeners.set(element, listener);\n\t\tthis._getObserver().observe(element, this.options);\n\t\treturn () => {\n\t\t\tthis._listeners.delete(element);\n\t\t\tthis._observer.unobserve(element); // this line can probably be removed\n\t\t};\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_getObserver() {\n\t\treturn (\n\t\t\tthis._observer ??\n\t\t\t(this._observer = new ResizeObserver((entries) => {\n\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\tResizeObserverSingleton.entries.set(entry.target, entry);\n\t\t\t\t\tthis._listeners.get(entry.target)?.(entry);\n\t\t\t\t}\n\t\t\t}))\n\t\t);\n\t}\n}\n\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { append_empty_stylesheet, detach, get_root_for_style } from './dom.js';\nimport { raf } from './environment.js';\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\n/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */\nconst managed_styles = new Map();\n\nlet active = 0;\n\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\n/**\n * @param {string} str\n * @returns {number}\n */\nfunction hash(str) {\n\tlet hash = 5381;\n\tlet i = str.length;\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn hash >>> 0;\n}\n\n/**\n * @param {Document | ShadowRoot} doc\n * @param {Element & ElementCSSInlineStyle} node\n * @returns {{ stylesheet: any; rules: {}; }}\n */\nfunction create_style_information(doc, node) {\n\tconst info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n\tmanaged_styles.set(doc, info);\n\treturn info;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {number} a\n * @param {number} b\n * @param {number} duration\n * @param {number} delay\n * @param {(t: number) => number} ease\n * @param {(t: number, u: number) => string} fn\n * @param {number} uid\n * @returns {string}\n */\nexport function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n\tconst step = 16.666 / duration;\n\tlet keyframes = '{\\n';\n\tfor (let p = 0; p <= 1; p += step) {\n\t\tconst t = a + (b - a) * ease(p);\n\t\tkeyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n\t}\n\tconst rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n\tconst name = `__svelte_${hash(rule)}_${uid}`;\n\tconst doc = get_root_for_style(node);\n\tconst { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n\tif (!rules[name]) {\n\t\trules[name] = true;\n\t\tstylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n\t}\n\tconst animation = node.style.animation || '';\n\tnode.style.animation = `${\n\t\tanimation ? `${animation}, ` : ''\n\t}${name} ${duration}ms linear ${delay}ms 1 both`;\n\tactive += 1;\n\treturn name;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {string} [name]\n * @returns {void}\n */\nexport function delete_rule(node, name) {\n\tconst previous = (node.style.animation || '').split(', ');\n\tconst next = previous.filter(\n\t\tname\n\t\t\t? (anim) => anim.indexOf(name) < 0 // remove specific animation\n\t\t\t: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n\t);\n\tconst deleted = previous.length - next.length;\n\tif (deleted) {\n\t\tnode.style.animation = next.join(', ');\n\t\tactive -= deleted;\n\t\tif (!active) clear_rules();\n\t}\n}\n\n/** @returns {void} */\nexport function clear_rules() {\n\traf(() => {\n\t\tif (active) return;\n\t\tmanaged_styles.forEach((info) => {\n\t\t\tconst { ownerNode } = info.stylesheet;\n\t\t\t// there is no ownerNode if it runs on jsdom.\n\t\t\tif (ownerNode) detach(ownerNode);\n\t\t});\n\t\tmanaged_styles.clear();\n\t});\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro — restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro — we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro — needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","const _boolean_attributes = /** @type {const} */ ([\n\t'allowfullscreen',\n\t'allowpaymentrequest',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'defer',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'inert',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'selected'\n]);\n\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n *\n * @type {Set<string>}\n */\nexport const boolean_attributes = new Set([..._boolean_attributes]);\n\n/** @typedef {typeof _boolean_attributes[number]} BooleanAttributes */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.2';\nexport const PUBLIC_VERSION = '4';\n","import {\n\tcustom_event,\n\tappend,\n\tappend_hydration,\n\tinsert,\n\tinsert_hydration,\n\tdetach,\n\tlisten,\n\tattr\n} from './dom.js';\nimport { SvelteComponent } from './Component.js';\nimport { is_void } from '../../shared/utils/names.js';\nimport { VERSION } from '../../shared/version.js';\nimport { contenteditable_truthy_values } from './utils.js';\nimport { ensure_array_like } from './each.js';\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @returns {void}\n */\nexport function dispatch_dev(type, detail) {\n\tdocument.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append_dev(target, node) {\n\tdispatch_dev('SvelteDOMInsert', { target, node });\n\tappend(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append_hydration_dev(target, node) {\n\tdispatch_dev('SvelteDOMInsert', { target, node });\n\tappend_hydration(target, node);\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert_dev(target, node, anchor) {\n\tdispatch_dev('SvelteDOMInsert', { target, node, anchor });\n\tinsert(target, node, anchor);\n}\n\n/** @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert_hydration_dev(target, node, anchor) {\n\tdispatch_dev('SvelteDOMInsert', { target, node, anchor });\n\tinsert_hydration(target, node, anchor);\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach_dev(node) {\n\tdispatch_dev('SvelteDOMRemove', { node });\n\tdetach(node);\n}\n\n/**\n * @param {Node} before\n * @param {Node} after\n * @returns {void}\n */\nexport function detach_between_dev(before, after) {\n\twhile (before.nextSibling && before.nextSibling !== after) {\n\t\tdetach_dev(before.nextSibling);\n\t}\n}\n\n/**\n * @param {Node} after\n * @returns {void}\n */\nexport function detach_before_dev(after) {\n\twhile (after.previousSibling) {\n\t\tdetach_dev(after.previousSibling);\n\t}\n}\n\n/**\n * @param {Node} before\n * @returns {void}\n */\nexport function detach_after_dev(before) {\n\twhile (before.nextSibling) {\n\t\tdetach_dev(before.nextSibling);\n\t}\n}\n\n/**\n * @param {Node} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @param {boolean} [has_prevent_default]\n * @param {boolean} [has_stop_propagation]\n * @param {boolean} [has_stop_immediate_propagation]\n * @returns {() => void}\n */\nexport function listen_dev(\n\tnode,\n\tevent,\n\thandler,\n\toptions,\n\thas_prevent_default,\n\thas_stop_propagation,\n\thas_stop_immediate_propagation\n) {\n\tconst modifiers =\n\t\toptions === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n\tif (has_prevent_default) modifiers.push('preventDefault');\n\tif (has_stop_propagation) modifiers.push('stopPropagation');\n\tif (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');\n\tdispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n\tconst dispose = listen(node, event, handler, options);\n\treturn () => {\n\t\tdispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n\t\tdispose();\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr_dev(node, attribute, value) {\n\tattr(node, attribute, value);\n\tif (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n\telse dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\n\n/**\n * @param {Element} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nexport function prop_dev(node, property, value) {\n\tnode[property] = value;\n\tdispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} property\n * @param {any} [value]\n * @returns {void}\n */\nexport function dataset_dev(node, property, value) {\n\tnode.dataset[property] = value;\n\tdispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_dev(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\tdispatch_dev('SvelteDOMSetData', { node: text, data });\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable_dev(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\tdispatch_dev('SvelteDOMSetData', { node: text, data });\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable_dev(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable_dev(text, data);\n\t} else {\n\t\tset_data_dev(text, data);\n\t}\n}\n\nexport function ensure_array_like_dev(arg) {\n\tif (\n\t\ttypeof arg !== 'string' &&\n\t\t!(arg && typeof arg === 'object' && 'length' in arg) &&\n\t\t!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)\n\t) {\n\t\tthrow new Error('{#each} only works with iterable values.');\n\t}\n\treturn ensure_array_like(arg);\n}\n\n/**\n * @returns {void} */\nexport function validate_slots(name, slot, keys) {\n\tfor (const slot_key of Object.keys(slot)) {\n\t\tif (!~keys.indexOf(slot_key)) {\n\t\t\tconsole.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n\t\t}\n\t}\n}\n\n/**\n * @param {unknown} tag\n * @returns {void}\n */\nexport function validate_dynamic_element(tag) {\n\tconst is_string = typeof tag === 'string';\n\tif (tag && !is_string) {\n\t\tthrow new Error('<svelte:element> expects \"this\" attribute to be a string.');\n\t}\n}\n\n/**\n * @param {undefined | string} tag\n * @returns {void}\n */\nexport function validate_void_dynamic_element(tag) {\n\tif (tag && is_void(tag)) {\n\t\tconsole.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n\t}\n}\n\nexport function construct_svelte_component_dev(component, props) {\n\tconst error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n\ttry {\n\t\tconst instance = new component(props);\n\t\tif (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n\t\t\tthrow new Error(error_message);\n\t\t}\n\t\treturn instance;\n\t} catch (err) {\n\t\tconst { message } = err;\n\t\tif (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n\t\t\tthrow new Error(error_message);\n\t\t} else {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n *\n * Can be used to create strongly typed Svelte components.\n *\n * #### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponent } from \"svelte\";\n * export class MyComponent extends SvelteComponent<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @extends {SvelteComponent<Props, Events>}\n */\nexport class SvelteComponentDev extends SvelteComponent {\n\t/**\n\t * For type checking capabilities only.\n\t * Does not exist at runtime.\n\t * ### DO NOT USE!\n\t *\n\t * @type {Props}\n\t */\n\t$$prop_def;\n\t/**\n\t * For type checking capabilities only.\n\t * Does not exist at runtime.\n\t * ### DO NOT USE!\n\t *\n\t * @type {Events}\n\t */\n\t$$events_def;\n\t/**\n\t * For type checking capabilities only.\n\t * Does not exist at runtime.\n\t * ### DO NOT USE!\n\t *\n\t * @type {Slots}\n\t */\n\t$$slot_def;\n\n\t/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */\n\tconstructor(options) {\n\t\tif (!options || (!options.target && !options.$$inline)) {\n\t\t\tthrow new Error(\"'target' is a required option\");\n\t\t}\n\t\tsuper();\n\t}\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tsuper.$destroy();\n\t\tthis.$destroy = () => {\n\t\t\tconsole.warn('Component was already destroyed'); // eslint-disable-line no-console\n\t\t};\n\t}\n\n\t/** @returns {void} */\n\t$capture_state() {}\n\n\t/** @returns {void} */\n\t$inject_state() {}\n}\n/**\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n * @template {Record<string, any>} [Slots=any]\n * @deprecated Use `SvelteComponent` instead. See PR for more information: https://github.com/sveltejs/svelte/pull/8512\n * @extends {SvelteComponentDev<Props, Events, Slots>}\n */\nexport class SvelteComponentTyped extends SvelteComponentDev {}\n\n/** @returns {() => void} */\nexport function loop_guard(timeout) {\n\tconst start = Date.now();\n\treturn () => {\n\t\tif (Date.now() - start > timeout) {\n\t\t\tthrow new Error('Infinite loop detected');\n\t\t}\n\t};\n}\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","<script lang=\"ts\">\n\timport { createEventDispatcher, onMount } from 'svelte';\nexport let samp: string = `\n    \\\\infer{\\\\land}{E}{\n            A\n            &\n            \\\\infer{\\\\lor}{D}{B & C}\n        }\n    `;\n`\\\\newcommand{\\\\infer}[3]{\\\\cfrac{#2\\\\qquad #3}{#2 \\\\wedge #3}\\\\small{#1}}`\n\n\nconst map = { //here is where we're going to store constants, I just think it looks better this way, this is the same as just declaring them as constants except now you need to preface their names with 'map.'(I am writing this as example easy code by the way if any programmers are wondering why it looks like this)\n    splitr: \"&\",\n    splitrRep: \"\\\\qquad \",\n    labelMark: \"=\",\n    singleVarRep: \"\\\\lower5pt\", //TODO: remove awkward height of single variables when next to large formulas\n    entail: \"*\",\n    entailRep: \"\\\\vdots\"\n\n};\n    let output: string = 'CONTENTS NOT LOADED'\nonMount(() => {\n    let ns:string[] = []; //We make an array and then push each individual character present in the string into the array, in typescript, you declare the type of a variable with :type after the name of the variable in its declaration\n    function addAll (arr: string[], str: string){\n            for(let ii = 0; ii < str.length; ii++){\n                arr.push(str.charAt(ii));\n            }\n        return arr;\n    }\n    for(let i = 0; i < samp.length; i++){\n        let char = samp.charAt(i)\n\n        if(char == map.splitr){\n            ns = addAll(ns, map.splitrRep);\n        }\n\n\n        else if(char == map.entail){\n            let labelIndices: number[] = [];\n            for(let ii=i; ii < samp.length; ii++){\n                    if(samp.charAt(ii) == \"{\"){labelIndices[0] = ii}\n                    if(samp.charAt(ii) == \"}\"){labelIndices[1] = ii; break;}\n            } \n            ns = addAll(ns, samp.substring(labelIndices[0], labelIndices[1]-1));\n            ns = addAll(ns, map.entailRep + \"}\");\n            i = i+map.entailRep.length + labelIndices[1]-labelIndices[0];\n        }\n        else if(char == map.labelMark){\n            let labelIndices: number[] = [];\n            for(let ii=i; ii < samp.length; ii++){\n                if(samp.charAt(ii) == \"[\" || samp.charAt(ii) == \"]\"){\n                    labelIndices.push(ii);\n                }\n            } \n            const str = \"{\" + samp.substring(labelIndices[0]+1, labelIndices[1]-2) + \"}\"; \n            ns = addAll(ns, str);\n            i = i+str.length+2;\n        }\n\n        else{\n            ns.push(samp.charAt(i));\n        }\n    }\n    output = ns.join(\"\"); \n})\n</script>\n\n<main>\n    <div>\n        {@html output}\n    <div>\n</main>\n","\n<script context=\"module\" lang=\"ts\">\n    declare var MathJax: any;\n</script>\n<script lang=\"ts\">\n    const mjsource = \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\";\n\timport { createEventDispatcher, onDestroy, onMount } from 'svelte';\n\tonMount(() => {\n        //mathJax\n        let script = document.createElement('script');\n        script.src = mjsource;\n\n\n    script.onload = () => {\n        console.log(\"MathJax Loaded\");\n      MathJax = {\n        tex: {inlineMath: [['$', '$'], ['\\\\(', '\\\\)']],\n        },\n        svg: {fontCache: 'global'}\n      };\n    };\n\n\t    console.log(\"Here\")\n        document.head.append(script);\n\t}\n    );\n    onDestroy(() => {\n        let scripts = document.head.getElementsByTagName(\"script\");\n        for (const scr of scripts ){\n        if (scr.getAttribute(\"src\")==mjsource) {\n            scr.remove();\n        }\n        };\n    });\n</script>\n","<script lang=\"ts\">\n    import Swap from './Swap.svelte'\n    import MathJax from './MathJax.svelte'\n    \n    export let ref; //for styling\n    export let page: string; //for styling\n    console.log(page);\n\n    export const load = (async () => {\n        return page;\n    })\n\n</script>\n\n\n<div class=\"document\">\n   <MathJax></MathJax>\n    \\({\"\\\\newcommand{\\\\infer}[3]{\\\\cfrac{#3}{#2}\\\\small{#1}}\"}\\)\n        <Swap samp={page}/>\n</div>\n\n<style>\n    div {\n        background-color: #ffffff;\n        color: rgb(54, 54, 54);\n    }\n    h1 {\n        font-family: \"Eczar\", serif;\n        font-weight: bold;\n    }\n    p {\n        font-family: \"Eczar\", serif;\n    }\n\n    .document {\n        border-width:5px;\n        border-color:black;\n        text-align: center;\n        position:relative;\n        left:15vw;\n        width: 52vw;\n        overflow: scroll;\n    }\n</style>\n","<script lang=\"ts\">\n    import { createEventDispatcher } from \"svelte\";\n    const dispatch = createEventDispatcher();\n    function event(documentName: string) {\n\n        console.log(\"emitting event, button pressed: \" + documentName);\n\n        dispatch ('documentSelection', {\n            document: documentName \n        });\n    }\n\n</script>\n\n<div class = 'sidebar'>\n   <!-- <slot/> -->\n\n   <div>\n    <h1>\n      <a href=\"\">Logic Manual</a>\n    </h1>\n      <div class = \"links_to_pages\">\n        <ul>\n          <button on:click={() => event(\"Introduction\")}>Introduction to LEAN</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"Propositional\")}>Propositional Logic</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"Conjunction\")}>Conjunction</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"Conditional\")} >Conditional</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"Disjunction\")} >Disjunction</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"Negation\")} >Negation</button>\n        </ul>\n        <ul>\n          <button on:click={() => event(\"CombinedRules\")} >Putting it all together</button>\n        </ul>\n      </div>\n   </div>\n</div>\n\n\n<style>\n  .sidebar {\n    position: fixed;\n    width: 15vw;\n    left: 0;\n    border: 3px solid;\n    border-color: #36454F;\n    background: white;\n    border-radius: 35px;\n    height: 100vh;\n    /* z-index: 3; */\n    color: rgb(13, 13, 13);\n    transition: all ease .3s;\n    text-align: center;\n    overflow: hidden;\n  }\n\n  .links_to_pages{\n    color: black;\n    text-align: left;\n    margin-right: 30px;\n    text-decoration: none;\n    &:hover{\n      text-decoration: none;\n    }\n  }\n</style>\n","<script lang=\"ts\">\n    import { onMount } from 'svelte';\n    export let editorUrl;\n    let frame: HTMLIFrameElement;\n    let frameActive = true;\n    console.log(editorUrl);\n</script>\n        {#key editorUrl}\n            <iframe bind:this={frame} src = {editorUrl} width = \"300\" height = \"100vh\"></iframe>\n        {/key}  \n\n<style>\n    iframe {\n        position: fixed;\n        overflow: hidden;\n        flex: 0.8 0 0px;\n        right: 0;\n        top: 0;\n        height: 100vh;\n        width: 30vw;\n    }\n</style>\n","export default \"<h3> Combination of Rules</h3>\\n        <p>\\n            Let's look at some example natural deduction proofs combining the rules introduced above. We will discuss one example together and then there are some more exercises in the LEAN editor.  \\n        </p>\\n        <p>\\n            Example1:  $A\\\\lor (B \\\\land C)\\\\vdash (A\\\\lor B) \\\\land (A \\\\lor C)$\\n            $$\\\\infer{\\\\land Intro}{ (A\\\\lor B) \\\\land (A \\\\lor C)} \\n            {\\\\infer{\\\\lor Elim}{A \\\\lor B}{A\\\\lor (B \\\\land C) &\\n            \\\\infer{\\\\lor Intro}{A\\\\lor B}{A}& \\\\infer{\\\\lor Intro}{A\\\\lor B}{\\\\infer{\\\\land Elim}{B}{B\\\\land C}}} & \\n            \\\\infer{\\\\lor Elim}{A\\\\lor C}{A\\\\lor (B \\\\land C) & \\\\infer{\\\\lor Intro}{A\\\\lor C}{A}& \\\\infer{\\\\lor Intro}{A\\\\lor C}{\\\\infer{\\\\land Elim}{C}{B\\\\land C}}}} $$   \\n        </p>\\n\";","export default \"<h3> Conditional</h3>\\n<p> The inference rules for the classical material conditional in propositional logic are the following: \\n    $$\\\\infer{\\\\rightarrow Intro}{A\\\\rightarrow B} {\\\\underset{B}{\\\\overset{[A]}{\\\\vdots} }}$$ \\n\\n    $$\\\\infer{\\\\rightarrow Elim}{B} {A\\\\rightarrow B&A}$$\\n</p>\\n<p> Their LEAN implementation functions in a parallel way. First, let's look at the simpler case, the elimination of the conditional, the rule of Modus Ponens. \\n    The rule goes as follows, given two assumptions $(h1: A \\\\rightarrow B)$ $(h2: A)$ you can deduce B. In LEAN this is simply written as: \\n     <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">h1</span> h2\\n    </pre></div> \\n    The introduction of the conditional is slightly more complex. By the introduction of the conditional, one discharges the assumption of the antecedent. In our case the assumption is A. \\n    The discharged assumption is indicated by the square brackets [ ] in the rule of propositional logic. In LEAN this discharging of the assumption works via a so called tactic. The tactic is fun and may be familiar to you from $\\\\lambda$ calculus. But this is not important here, it simply works like an assumption:  </p>\\n    <p>\\n    fun h: Antecedent $\\\\Rightarrow$ Consequent\\n    </p>\\n    <p>\\n    $\\\\Rightarrow$ can be written using your keyboard, first the equality sign and then the greater than. See the code editor for an example. \\n    The h: stands for hypothesis, you designate the Antecedent as an hypothesis.  You can define more complex statements in the antecedent. But importantly, with the assumption of the antecedent, you prove the consequent. </p>\\n    Here are three examples of natural deduction proofs involving the rules for the conditional. \\n    There are some more examples so that the functioning of the fun tactic becomes clear.\\n    Below you see the deduction in propositional logic, see the code editor for their LEAN implementation.\\n   </par>\\n   <par>\\n    Example 1: $A \\\\rightarrow B, B\\\\rightarrow C, A \\\\vdash C$\\n\\n    $$\\\\infer{\\\\rightarrow Elim}{C}{B\\\\rightarrow C &\\\\infer{\\\\rightarrow Elim}{B}{A\\\\rightarrow B & A}}$$\\n\\n    Example 2: $\\\\vdash A \\\\rightarrow A \\\\land A$\\n\\n    $$\\\\infer{\\\\rightarrow Intro}{A\\\\rightarrow A \\\\land A}{\\\\infer=[\\\\land Intro]{A\\\\land A}{[A] & {[A]}}}$$\\n\\n    Example 3: $A\\\\rightarrow B, B\\\\rightarrow C \\\\vdash A \\\\rightarrow C$\\n    $$\\\\infer{\\\\rightarrow Intro}{A\\\\rightarrow C}{\\\\infer{\\\\rightarrow Elim} {C}{B \\\\rightarrow C & \\\\infer{\\\\rightarrow Elim}{B} {A\\\\rightarrow B & [A]}}}$$ \\n</p>\\n<p>\\n    Now you can test your understanding in the exercises in the LEAN editor and replace the \\\"sorry\\\" placeholders with your deductions.\\n</p>\";","export default \"<h3>Conjunction</h3>\\n        <p> The well-known rules for conjunction in propositional logic are the following:\\n            $$\\\\infer{\\\\land Intro}{A\\\\land B}{A&B}$$ \\n            $$\\\\infer{\\\\land Elim} {A} {A\\\\land B}$$ \\n            $$\\\\infer{\\\\land Elim} {B} {A\\\\land B}$$ </p> \\n\\n    In the programming language LEAN, the rules function similarly. For example, in the LEAN syntax you write:\\n<div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">And</span>.right h\\n</pre></div>\\n    This extracts from the hypothesis h: $A \\\\land B$ the right conjunct A.\\n\\n    Similarly, to get the left conjunct, you can use the following syntax in LEAN\\n\\n<div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #BB0066; font-weight: bold\\\"></span><span style=\\\"color: #333333\\\"></span>  <span style=\\\"color: #000000; font-weight: bold\\\">And</span><span style=\\\"color: #333333\\\">.</span><span style=\\\"color: #008800; font-weight: bold\\\">left</span> h\\n</pre></div>\\n\\n    We have to be specific in LEAN, indicating exactly which conjunct we want to extract. \\n    For the introduction of a conjunction of A and B we write:\\n\\n<div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">And</span>.intro <span style=\\\"color: #BB0066; font-weight: bold\\\">A</span> <span style=\\\"color: #BB0066; font-weight: bold\\\">B</span>\\n</pre></div>\\n\\n<div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">And</span>.intro hA hB\\n</pre></div>\\n\\n   The latter formulation works for hypothesis hA, hB respectively. \\n</p>\\n<p>\\n   Next let us consider an example natural deduction proof involving both the introduction and the elimation rules for conjunction: \\n       </p>\\n         <p>\\n        Example 1: $B \\\\land A \\\\vdash A \\\\land B$\\n         $$\\\\infer{\\\\land Intro}\\n             {A\\\\land B} \\n               {\\\\infer{\\\\land Elim} {A} {B \\\\land A}\\n               & \\\\infer{\\\\land Elim}{B} {B \\\\land A}}\\n                  $$\\n        </p>\\n    This proof is also done in LEAN; as you can see in the code editor on the page. \\n    This should give you an example to then continue the exercises in LEAN using the syntax for conjunction we just introduced. There are easier and harder exercises. You just remove the \\\"sorry\\\" placeholer and write your proof. You should be able to see LEAN messages regarding your proof. \\n\\n    <p> \\n        Lastly, there is one helpful tool. When you write down natural deduction proofs on paper, you might want to use intermediary steps, similarly online. See for example the last hard exercise in the LEAN editor. It could be helpful to prove C as an intermediary goal there.\\n        LEAN allows you to do this by writing \\n        <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #BB0066; font-weight: bold\\\"></span><span style=\\\"color: #333333\\\"></span>  <span style=\\\"color: #000000; font-weight: bold\\\">show</span><span style=\\\"color: #333333\\\"> C </span><span style=\\\"color: #008800; font-weight: bold\\\">from And.right (And.right h)</span>\\n        </pre></div>\\n        \\n    </p>\\n\\n\";","export default \"<h3>Disjunction</h3>\\n        <p> \\n            The rules for disjunction in propositional logic are the following: \\n            $$\\\\infer{\\\\lor Intro} {A\\\\lor B} {A}$$   $$\\\\infer{\\\\lor Intro} {A\\\\lor B} {B}$$ \\n            $$\\\\infer{\\\\lor Elim} {C} {A \\\\lor B & {\\\\underset{C}{\\\\overset{[A]}{\\\\vdots}}} & {\\\\underset{C}{\\\\overset{[B]}{\\\\vdots}}}}$$\\n        </p>\\n        <p> The syntax of the rules in LEAN is again very similar. For the introduction of the disjunction, you can use one of the following. Note in LEAN the order of the disjuncts matters.\\n            <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">Or.intro_left</span> A  B \\n            </pre></div>\\n            <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">Or.intro_right</span> B  A \\n            </pre></div> \\n            The syntax for the disjunction elimination rule is a bit more complicated. You need to show that C follows from both A and B independently to be able to eliminate the disjunction.\\n            This is done using the same tactic we saw with the conditional \\\"fun\\\". So we write \\n            $$\\\\text{Or.elim } A \\\\lor B \\\\quad (\\\\text{ fun } h1: A \\\\Rightarrow C) ( \\\\text{fun } h1:B \\\\Rightarrow C)$$\\n           \\n        <p>\\n            Now look at an example natural deduction proof using the rules for conjunction and its implementation in LEAN. \\n            Example 1: $A\\\\lor B \\\\vdash A \\\\lor (B \\\\lor C)$\\n            $$\\\\infer{\\\\lor Elim}{A\\\\lor (B \\\\lor C)}{A\\\\lor B &\\\\infer{\\\\lor Intro}{A\\\\lor (B\\\\lor C)}{[A]} & \\\\infer{\\\\lor Intro}{A\\\\lor (B\\\\lor C)}{\\\\infer{\\\\lor Intro}{B\\\\lor C}{[B]}}} $$\\n            And there are again some exercises for you to complete in LEAN in the editor. \\n        </p>\\n    \\n\";","export default \"<html>\\n  <head>\\n    <link rel=\\\"stylesheet\\\" href=\\\"introduction.css\\\">\\n    <!-- Link to an external CSS file -->\\n    <link rel=\\\"stylesheet\\\" href=\\\"style.css\\\">\\n    <!-- Load MathJax script -->\\n    <script src=\\\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\\\"></script>\\n    <script type=\\\"text/javascript\\\">\\n      MathJax.Hub.Config({\\n      tex2jax: {\\n      inlineMath: [ ['$','$'], ['\\\\\\\\(','\\\\\\\\)'] ]\\n          }\\n        });\\n    </script>\\n  </head>\\n\\n  <body>\\n    <div class=\\\"container\\\">\\n      <!-- Use semantic elements for structure -->\\n      <nav class=\\\"navbar\\\">\\n        <!-- Use descriptive class names -->\\n        <div>\\n          <h1 class=\\\"logo\\\"><a href=\\\"index.html\\\">LEAN and the Logic Manual</a></h1>\\n        </div>\\n      </nav>\\n\\n      <section class=\\\"lean_intro\\\">\\n        <!-- Use section element for each section -->\\n        <article class=\\\"lean_intro_body\\\">\\n          <!-- Use article element for main content -->\\n          <h1> Introduction To Using Lean </h1>\\n          <p> This section gives you the fundamental background to using LEAN. We introduce the LEAN syntax so that you can write the logical connectives.  \\n              This will be particularly helpful in the next sections, when we go through the introduction and elimination rules of each connective. You will be able to verify your reasoning directly, being guided by the LEAN editor. </p>\\n          <p> LEAN is an automated theorem prover so if you input your deduction, it will show you errors and lead you to the correct path. \\n              We will familiarise ourselves with the basic reasoning in propositional logic, but LEAN is much more powerful. It is used for example at Imperial College by Kevin Buzzard to teach mathematics to undergraduates. The tool can help verify diffuclt proofs.\\n            </p>\\n            <p> \\n            With this resource, you can familiarise yourself with the basics of the LEAN and learn logical deductions. \\n          \\n            You will have already seen the LEAN editor on the right. This is where you can write LEAN. \\n            But before writing in LEAN, we need to learn its syntax. \\n            How can you write the connective in the programming language? See the table below for instructions:\\n          </p>\\n\\n        <article class=\\\"syntax_para\\\">\\n            <h2> Using Connectives in Lean</h2>\\n            <table class=\\\"syntax_table\\\">\\n              <colgroup>\\n                <col style=\\\"border: 17%\\\">\\n                <col style=\\\"width: 30%\\\">\\n                <col style=\\\"width: 52%\\\">\\n              </colgroup>\\n              <tbody>\\n                <tr class=\\\"row-odd\\\">\\n                  <td>\\n                    <p>Symbol </p>\\n                    </td>\\n                  <td>\\n                    <p>LEAN </p>\\n                    </td>\\n                  <td>\\n                    <p>English </p>\\n                  </td>\\n                  <td>\\n                    <p>Connective</p>\\n                  </td>\\n                </tr>\\n                <tr class=\\\"row-even\\\">\\n                  <td>\\n                    <p>∨</p>\\n                    </td>\\n                  <td>\\n                    <p>\\\\or</p>\\n                    </td>\\n                    <td>\\n                      <p>or </p>\\n                    </td>\\n                    <td>\\n                      <p>Disjunction</p>\\n                    </td>\\n                </tr>\\n                <tr class=\\\"row-odd\\\">\\n                  <td>\\n                    <p>∧</p>\\n                    </td>\\n                  <td>\\n                    <p>\\\\and</p>\\n                    </td>\\n                  <td>\\n                    <p> and </p>\\n                  </td>\\n                  <td>\\n                    <p>Conjunction</p>\\n                  </td>\\n                </tr>\\n                <tr class=\\\"row-even\\\">\\n                  <td>\\n                    <p>→</p>\\n                    </td>\\n                  <td>\\n                    <p>\\\\to, \\\\r, \\\\imp </p>\\n                    </td>\\n                  <td>\\n                    <p>if ... then </p>\\n                  </td>\\n                  <td>\\n                    <p>Conditional</p>\\n                  </td>\\n                </tr>\\n                <tr class=\\\"row-odd\\\">\\n                  <td>\\n                    <p>↔︎</p>\\n                    </td>\\n                  <td>\\n                    <p>\\\\iff, \\\\lr</p>\\n                    </td>\\n                  <td>\\n                    <p>if and only if </p>\\n                  </td>\\n                  <td>\\n                    <p>Biconditional </p>\\n                  </td>\\n                </tr>\\n                <tr class=\\\"row-even\\\">\\n                  <td>\\n                    <p>￢</p>\\n                    </td>\\n                  <td>\\n                    <p>\\\\not, \\\\neg</p>\\n                    </td>\\n                  <td>\\n                    <p>not </p>\\n                  </td>\\n                  <td>\\n                    <p>Negation </p>\\n                  </td>\\n                </tr>\\n              </tbody>\\n            </table>\\n        </article>\\n      </section>\\n    </div>\\n    You may have noticed the following line at the top of the LEAN editor window:\\n        <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">variable</span>(A B C D: Prop)\\n        </pre></div>\\n    It specifies propositions in the language. In the Logic Manual, Halbach calls these sentence letters. Now a proposition is a sentence which has a truth value. \\n    A semantic structure assigns a truth value to exactly every sentence letter of the language. Hence, we can understand the sentence letters as propositions here. The semantics of propositional logic are discussed in detail in the next section.\\n    <p>\\n    By definition 2.2 in the Logic Manual, we know for sentence letters A,B that binary connectives $\\\\land, \\\\lor, \\\\rightarrow, \\\\leftrightarrow$ produce new sentences $A\\\\land B, A\\\\lor B, A\\\\rightarrow B, A \\\\leftrightarrow B$.\\n    Similarly, for a sentence A and negation, $\\\\neg A$ is also a sentence.\\n    You can confirm this by hovering over the statements in the code editor. We defined A, B as propositions and hence if we check expressions such as $A\\\\land B$, LEAN will give that these are also propositions.\\n    We look at the semantics in the next section.\\n    </p>\\n    <p>\\n      Acknowledgements: This project depends on the resources of the Book\\n      <a href=\\\"https://leanprover.github.io/logic_and_proof/index.html\\\">Logic and Proof</a> especially pertaining to LEAN,\\n      the <a href=\\\"https://users.ox.ac.uk/~logicman/\\\">Resources</a>\\n      of the Logic Manual Book by Volker Halbach are the fundation for all exercises. In particular, the Natural Deduction Pack.\\n      Moreover, we use the server of the ADAM project of HHU Düsseldorf. \\n    </p>\\n</body>\\n</html>\\n\";","export default \"<h3> Negation</h3>\\n        <p>\\n            The rules for negation in propositional logic are well known to you.  \\n            $$\\\\infer{\\\\neg Intro} {\\\\neg A} { {\\\\underset{B}{\\\\overset{[A]}{\\\\vdots}} &  {\\\\underset{\\\\neg B}{\\\\overset{[A]}{\\\\vdots}}}}}$$  $$\\\\infer{\\\\neg Elim } { A}  {\\\\underset{B}{\\\\overset{[\\\\neg A]}{\\\\vdots}} &  {\\\\underset{\\\\neg B}{\\\\overset{[\\\\neg A]}{\\\\vdots}}}}$$\\n        </p>\\n        <p>\\n            This works differently in LEAN. Negation $\\\\neg A$ is here defined as $A \\\\rightarrow \\\\bot$, where $\\\\bot$ is a contradiction such as $ 0\\\\neq 0 $ for example.\\n            There are two main tactics for negation in LEAN. The first one is similar to negation introduction. If you want to prove $\\\\neg A$ then you assume $A$ and show that it leads to a contradiction. \\n            This assumption is constructed similarly to the conditional and disjunctive rules above. So under the assumption  $h1:$ $ A$, you proof a contradiction (this is called False in LEAN). Then you get the desired result $\\\\neg A$. It is written as follows:\\n            $$ \\\\text{fun }h: A, \\\\text{ show False from } h1 \\\\quad h$$\\n           \\n            Here h1 and h, defined as $\\\\neg A$ and $A$ respectively, gives the False. Note that the order matters here, the negated statement must come first. \\n        </p>\\n        <p></p>\\n            The second tactic involving negation used in LEAN is the so called Ex falso quodlibet principle, which you have seen in class as well. It states that anything can be derived from a contradiction. In LEAN this is done by a new tactic: absurd. \\n            So suppose you are given some contradictory assumptions such as h1: $ A$ and h2: $\\\\neg A$. Then you can prove any claim $B$ simply by stating \\n            <div style=\\\"background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;\\\"><pre style=\\\"margin: 0; line-height: 125%\\\"><span style=\\\"color: #fabd4e; font-weight: bold\\\">absurd</span> h2 h1\\n            </pre></div>\\n            Again here the order matters. \\n        </p>\\n        <p>\\n            Let's look at some example derivations both in propositional logic and LEAN. Again, you can find exercises in the editor. \\n            Example 1: $A\\\\rightarrow B, \\\\neg B\\\\vdash \\\\neg A$\\n            $$\\\\infer{\\\\neg Intro}{\\\\neg A}{\\\\infer{\\\\rightarrow Elim}{B}{A\\\\rightarrow B & [A]} & \\\\neg B}$$\\n            Example 2: $A\\\\land B, \\\\neg A\\\\vdash C$\\n            $$\\\\infer=[  ]{C}{\\\\infer{\\\\land Elim}{A}{A\\\\land B}&\\\\neg A}$$\\n        </p>\\n\";","export default \"<h1>\\n    Propositional Logic in LEAN\\n    </h1>\\n    <div>\\n       <p>\\n        In the introduction, we learned how to write compound sentences in LEAN. This section will discuss the semantics of Propositional Logic, following Chapter 5 of the Logic Manual. \\n        </p> \\n        <p>\\n        First, a small warning: please do not consider the first 6 lines of the code editor, this is just LEAN background functioning. \\n        You already will have seen that a semantic structure assigns truth values to sentences in the language. \\n        We do this here for a toy model by hand and declare sentences A, C as true and B, D as false. Now following the definition of satisfaction (Def 5.2) you can evaluate the truth value of compound expressions. \\n        This is typically done via truth tables, where you identify the central connective and then deduce whether the expression is true or false based on its components. \\n        Now LEAN does this automatically for you. If you hover over the #eval statements, then you should be able to see 'true' or 'false'. \\n        </p>\\n        <p>\\n        Test your own examples here! You can define your own assigments and evaluate more complex expression. This is a good place to learn using LEAN and familiarise yourself with the connectives. \\n        </p>\\n        In the next few sections, we will look at the natural deduction rules for propositional logic. We look at the introduction and elimination rules for each connective separately and learn their implementation in LEAN.\\n        This will allow you do natural deduction proofs in LEAN and have them checked automatically. \\n    \\n    \\n    \";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Combinations%20of%20rules%0Aexample%20(h%3AA%E2%88%A8%20(B%E2%88%A7%20C))%3A(A%E2%88%A8%20B)%20%E2%88%A7%20(A%20%E2%88%A8%20C)%3A%3D%0A%20%20And.intro%20%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AA%20%3D%3E%20Or.intro_left%20B%20h1)%0A%20%20(fun%20h2%3AB%E2%88%A7C%20%3D%3E%20Or.intro_right%20A%20(And.left%20h2)))%0A%20%20(Or.elim%20h%20%0A%20%20(fun%20h1%3AA%20%3D%3E%20Or.intro_left%20C%20h1)%0A%20%20(fun%20h2%3AB%E2%88%A7C%20%3D%3E%20Or.intro_right%20A%20(And.right%20h2)))%0A%0Aexample%20(h%3A%20(A%E2%86%92%20B)%E2%86%92%20B)%3A%20%C2%ACB%20%E2%86%92%20A%3A%3D%0A%20%20sorry%20%0A%0Aexample%20%3A%20%C2%AC%20(A%E2%88%A7B)%20%E2%86%92%20%20(%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%3A%3D%0A%20%20sorry%0A%0Aexample%3A%20%20(%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%20%E2%86%92%20%20%C2%AC%20(A%E2%88%A7B)%3A%3D%0A%20%20sorry%20%0A%0Aexample%20(h1%3A%20A%20%E2%86%92%20B)(h2%3A%20A%20%E2%88%A7%20%C2%AC%20B)%3A%20C%3A%3D%0A%20%20sorry%0A%20%20%0A%0A\";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Conditional%3A%20Example%20(See%20website)%0Aexample%20(h1%3A%20A%E2%86%92%20B)(h2%3A%20B%E2%86%92%20C)%20(h3%3A%20A)%3A%20C%3A%3D%0A%20%20h2%20(show%20B%20from%20h1%20h3)%0A%0Aexample%3A%20%20A%E2%86%92%20A%20%E2%88%A7%20A%3A%3D%0A%20%20%20fun%20h%3A%20A%20%3D%3E%20%20And.intro%20h%20h%20%0A%0Aexample%20(h1%3A%20A%E2%86%92%20B%20)(h2%3A%20B%E2%86%92%20C)%3A%20A%E2%86%92%20C%3A%3D%0A%20(fun%20h%3A%20A%3D%3E%0A%20%20show%20C%20from%20h2%20(show%20B%20from%20h1%20h))%0A%0A--%20easy%20Exercises%20%0Aexample%20(h1%3A%20A%E2%86%92%20B)(h2%3A%20A)%3A%20B%3A%3D%0Asorry%20%0A%0Aexample%3A%20A%E2%86%92%20B%3A%3D%0Asorry%20%0A%0Aexample%3A%20A%20%E2%86%92%20B%20%E2%86%92%20A%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20(A%E2%86%92B)%E2%86%92A%20)%3A%20B%E2%86%92%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%20%E2%86%92%20B%3A%3D%0Asorry%20%0A%0A%0A\";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A--%20Conjunction%3A%20Example%20(See%20Website)%0Aexample%20(h1%20%3A%20A%20%E2%88%A7%20B)%3A%20B%20%E2%88%A7%20A%20%3A%3D%0A%20%20And.intro%20(And.right%20h1)%20(And.left%20h1)%0A%0A--%20easy%20Exercises%20%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20B%3A%3D%0Asorry%20%20%0A%0Aexample%20(h%3A%20A%E2%88%A7B)%3A%20A%20%E2%88%A7%20B%20%E2%88%A7%20A%3A%3D%0Asorry%20%0A%0A--%20harder%20Exercises%20%0Aexample%20(h1%3A%20A%E2%88%A7B)(h2%3A%20C)%3A%20A%20%E2%88%A7%20B%20%E2%88%A7%20C%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20A%20%E2%88%A7%20(B%20%E2%88%A7%20C))%3A%20(C%20%E2%88%A7%20A)%20%E2%88%A7%20B%3A%3D%0Asorry%20%20%0A%0A\";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Disjunction%3A%20Example%20(See%20Website)%0Aexample%20(h%3AA%E2%88%A8%20B)%3AA%E2%88%A8%20(B%E2%88%A8%20C)%3A%3D%0A%20%20Or.elim%20h%0A%20%20(fun%20h1%3A%20A%20%3D%3E%20%0A%20%20%20%20%20%20show%20A%E2%88%A8%20(B%E2%88%A8C)%20from%20Or.intro_left%20(B%E2%88%A8C)%20h1)%0A%20%20(fun%20h2%3AB%20%3D%3E%20%0A%20%20%20%20show%20A%E2%88%A8%20(B%E2%88%A8C)%20from%20Or.intro_right%20A%20(Or.intro_left%20C%20h2))%0A%0A%0A--%20easy%20Exercises%0Aexample%20(h%3AA)%3AA%E2%88%A8%20B%3A%3D%0Asorry%0A%0Aexample%20(h%3AA%E2%88%A8B)%3A%20B%E2%88%A8%20A%3A%3D%0Asorry%0A%0Aexample%20(h%3A%20(A%20%E2%86%92%20B)%E2%88%A8%20B)%3A%20A%E2%86%92%20B%20%3A%3D%0Asorry%0A%0A--%20harder%20Exercises%0Aexample%20(h%3A%20(A%E2%88%A8%20B)%20%E2%88%A7%20(A%20%E2%88%A8%20C))%3A%20A%20%E2%88%A8%20(B%E2%88%A8%20C)%3A%3D%0Asorry%20%0A%0A%0A\";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A%23check%20A%20%E2%88%A8%20B%0A%0A%23check%20A%E2%88%A7%20B%0A%0A%23check%20A%20%E2%86%92%20B%0A%0A%23check%20A%20%E2%86%94%20B%0A%0A%23check%20%C2%AC%20A\\n\";","export default \"https://lean.math.hhu.de/#code=variable%20(A%20B%20C%20D%3A%20Prop)%20%0A%0A--%20Negation%3A%20Example%20(See%20Website)%0Aexample%20(h1%3AA%E2%86%92%20B)%20(h2%3A%20%C2%ACB)%3A%20%C2%AC%20A%3A%3D%0A%20%20fun%20h%3A%20A%3D%3E%0A%20%20show%20False%20from%20h2%20(h1%20h)%0A%0Aexample%20(h1%3A%20A%20%E2%88%A7%20B)(h2%3A%20%C2%AC%20A)%3A%20B%20%3A%3D%0A%20%20absurd%20(And.left%20h1)%20h2%0A%0A--easy%20Exercises%0Aexample%20(h1%3AA)%3A%20%C2%AC%20%C2%AC%20A%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20A)%20(h2%3A%20%C2%AC%20A)%3A%20B%3A%3D%0Asorry%0A%0Aexample%20(h1%3A%20A%E2%88%A7%20%C2%AC%20A)%3A%20B%3A%3D%0Asorry%20%0A%0Aexample%20(h1%3A%20A%20%E2%86%92%20%C2%ACA)%3A%20%C2%AC%20A%3A%3D%0Asorry%20%0A%0A--harder%20Exercises%0Aexample%20(h1%3A%20A%E2%86%92%20B)%20(h2%3A%20A%20%E2%88%A7%20%C2%AC%20B)%3A%20C%3A%3D%0Asorry%20%0A%0Aexample%20(h%3A%20%C2%AC%20A%20%E2%88%A8%20%C2%AC%20B)%3A%20%C2%AC%20(A%20%E2%88%A7%20B)%3A%3D%0Asorry%20%0A%0A%0A\";","export default \"https://lean.math.hhu.de/#code=inductive%20Bool%20%3A%20Type%20where%0A%20%20%7C%20false%0A%20%20%7C%20true%0A%0Adef%20interpret%20(p%3AProp)%20%5BDecidable%20p%5D%3A%20String%3A%3D%0Aif%20p%20then%20%22true%22%20else%20%22false%22%0A%0Adef%20A%20%3A%3D%20true%0Adef%20B%20%3A%3D%20false%0Adef%20C%20%3A%3D%20true%0Adef%20D%3A%3D%20false%20%0A%0A%23eval%20interpret%20(A%E2%88%A7B)%0A%23eval%20interpret%20(A%E2%88%A7%20(%C2%AC%20B%E2%88%A8%20%C2%ACC%20))%0A%23eval%20interpret%20(%C2%AC%20B%20%E2%86%92%20(A%20%E2%88%A8%20%C2%AC%20D))%0A%23eval%20interpret%20(D%20%E2%86%94%20(C%20%E2%88%A7%20A))\";","<script lang=\"ts\">\n    import Document  from './Document.svelte'\n    import Sidebar from './Sidebar.svelte'\n    import IFrameEditor from './IFrameEditor.svelte'\n\n    import CombinedRules from './static/documents/CombinedRules.x.html'\n    import Conditional from './static/documents/Conditional.x.html'\n    import Conjunction from './static/documents/Conjunction.x.html'\n    import Disjunction from './static/documents/Disjunction.x.html'\n    import Introduction from './static/documents/Introduction.x.html'\n    import Negation from './static/documents/Negation.x.html'\n    import Propositional from './static/documents/Propositional.x.html'\n\n\n    import CombinedRulesT from './static/exercises/CombinedRules.txt'\n    import ConditionalT from './static/exercises/Conditional.txt'\n    import ConjunctionT from './static/exercises/Conjunction.txt'\n    import DisjunctionT from './static/exercises/Disjunction.txt'\n    import IntroductionT from './static/exercises/Introduction.txt'\n    import NegationT from './static/exercises/Negation.txt'\n    import PropositionalT from './static/exercises/Propositional.txt'\n\n\n    let map = new Map();\n    map.set(\"CombinedRules\", [ CombinedRules, CombinedRulesT ])\n    map.set(\"Conditional\", [ Conditional, ConditionalT ])\n    map.set(\"Conjunction\", [ Conjunction, ConjunctionT ])\n    map.set(\"Disjunction\", [ Disjunction, DisjunctionT ])\n    map.set(\"Introduction\", [ Introduction, IntroductionT ])\n    map.set(\"Propositional\", [Propositional, PropositionalT])\n    map.set(\"Negation\", [ Negation, NegationT ])\n    //console.log(\"NegationT is : \" + NegationT);\n    let selectedDocument = Introduction;\n    let editorText = IntroductionT;//This sets text in editor and updates lean web editor component\n\n    function handlePageChange(event) {\n        const values = map.get(event.detail.document);\n        selectedDocument = values[0];\n        editorText = values[1]; //TODO: Resetting Editor Text Breaks IFrame Augh\n        console.log(\"caught event in App.svelte: \" + selectedDocument);\n        //TODO: Also need code to change editor content\n    }\n</script>\n<body>\n  <Sidebar on:documentSelection={handlePageChange}></Sidebar>\n  <main>\n    {#key selectedDocument}\n        <Document ref=\"document\" bind:page={selectedDocument}></Document>\n    {/key}\n\n    <IFrameEditor bind:editorUrl={editorText}/>\n\n  </main>\n</body>\n\n\n<style>\n\n  .container {\n    /* display: flex; */\n    width: 100%;\n\n  }\n\n\n\n  #footer{\n    background-color: white;\n    color: #36454F;\n    text-align: center;\n    position: fixed;\n    padding: 1em;\n    bottom: 0;\n  }\n\n\n\n    \n\n    @media (min-width: 640px) {\n        main {\n        \tmax-width: none;\n        }\n    }\n\n</style>\n","import './global.css';\n\nimport App from './App.svelte';\n\nconst app = new App({\n    target: document.body,\n    props: {\n        name : 'world'\n    }\n});\n\nexport default app;\n"],"names":["Set","globals","window","globalThis","global","ResizeObserverSingleton","_listeners","WeakMap","undefined","_observer","options","constructor","this","observe","element","listener","set","_getObserver","delete","unobserve","ResizeObserver","entries","entry","target","get","src_url_equal_anchor","is_hydrating","append","node","appendChild","append_styles","style_sheet_id","styles","append_styles_to","document","root","getRootNode","ownerDocument","host","getElementById","style","id","textContent","head","sheet","append_stylesheet","insert","anchor","insertBefore","parentNode","removeChild","name","createElement","data","createTextNode","space","attr","attribute","value","removeAttribute","getAttribute","setAttribute","type","detail","bubbles","cancelable","CustomEvent","HtmlTag","is_svg","e","n","t","a","c","html","h","m","createElementNS","nodeType","nodeName","tagName","content","i","innerHTML","Array","from","childNodes","length","p","d","forEach","add_location","file","line","column","char","__svelte_meta","loc","run","fn","Object","create","fns","thing","safe_not_equal","b","src_url_equal","element_src","url","href","component","Error","onMount","$$","on_mount","push","onDestroy","on_destroy","createEventDispatcher","callbacks","event","slice","call","defaultPrevented","Map","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_flush_callback","seen_callbacks","flushidx","saved_component","update","pop","callback","has","add","clear","fragment","before_update","dirty","ctx","after_update","outroing","outros","SvelteElement","block","local","detach","o","bind","index","props","bound","create_component","mount_component","new_on_destroy","map","filter","destroy_component","detaching","filtered","targets","indexOf","flush_render_callbacks","init","instance","create_fragment","not_equal","parent_component","on_disconnect","context","skip_bound","ready","ret","rest","then","fill","make_dirty","hydrate","nodes","l","intro","get_custom_element_value","prop","props_definition","transform","JSON","stringify","parse","HTMLElement","$$ctor","$$s","$$c","$$cn","$$d","$$r","$$p_d","$$l","$$l_u","$$componentCtor","$$slots","use_shadow_dom","super","attachShadow","mode","addEventListener","unsub","$on","removeEventListener","connectedCallback","create_slot","existing_slots","result","slot","get_custom_elements_slots","attributes","$$g_p","shadowRoot","$$scope","reflect_attributes","key","reflect","attribute_value","attributeChangedCallback","_oldValue","newValue","$set","disconnectedCallback","$destroy","attribute_name","keys","find","toLowerCase","SvelteComponent","$$set","splice","obj","VERSION","dispatch_dev","dispatchEvent","version","append_dev","insert_dev","detach_dev","listen_dev","handler","has_prevent_default","has_stop_propagation","has_stop_immediate_propagation","modifiers","dispose","listen","attr_dev","validate_slots","slot_key","console","warn","SvelteComponentDev","$$prop_def","$$events_def","$$slot_def","$$inline","$capture_state","$inject_state","__svelte","v","samp","splitr","splitrRep","labelMark","singleVarRep","entail","entailRep","output","ns","addAll","arr","str","ii","charAt","labelIndices","substring","join","mjsource","script","src","onload","log","MathJax","tex","inlineMath","svg","fontCache","scripts","getElementsByTagName","scr","remove","ref","page","load","dispatch","documentName","frame","editorUrl","frameActive","r","CombinedRules","Conditional","Conjunction","Disjunction","Introduction","Propositional","Negation","selectedDocument","editorText","handlePageChange","values","body"],"sourceRoot":""}